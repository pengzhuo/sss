---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by b_ree.
--- DateTime: 2019/11/2 15:11
---

local skynet = require "skynet"
local httpd = require "http.httpd"
local sockethelper = require "http.sockethelper"
local log = require "log"
local utils = require "utils"
local cjson = require "cjson"
local protobuf = require "pb"
local sharetable = require "skynet.sharetable"
local crypt = require "skynet.crypt"
local const_code = require "const_code"
local const_game = require "const_game"
require "functions"

local M = {}

local function response(id, code, data, ...)
    local header = ... or {}
    header["Content-Type"] = "text/html; charset=UTF-8"
    header['Access-Control-Allow-Origin'] = '*'
    local ok, err = httpd.write_response(sockethelper.writefunc(id), code, data, header)
    if not ok then
        skynet.error(string.format("fd = %d, %s", id, err))
    end
end

---检测房间接口
function M.room_check(_id, _url_query, _post_body, _addr)
    local resp = {code=9000}  -- 和原项目保持统一： 9000 房间不存在; 0 房间存在
    local data = cjson.decode(crypt.base64decode(_post_body))
    local room_server = skynet.call(".room_mgr_server", "lua", "get_room_serve", data.room_id)
    if room_server then
        resp.code = 0
    end
    local res = crypt.base64encode(cjson.encode(resp))
    response(_id, 200, res)
end

---创建房间接口
function M.create_room(_id, _url_query, _post_body, _addr)
    local resp = {code=const_code.FAILURE}
    local ok, data = pcall(protobuf.decode, table.concat({const_game.PB_NAMESPACE, ".CreateRoomRequest"}), _post_body)
    if ok then
        local kwargs = cjson.decode(data.kwargs)
        if kwargs.gps == 1 then --GPS预警
            local ok, info = pcall(cjson.decode, data.owner_info)
            if ok and type(info.location) == "table" then
                if table.nums(info.location) < 2 then
                    resp.code = const_code.ROOM_GPS_WARNING
                    local res = protobuf.encode(table.concat({const_game.PB_NAMESPACE, ".CreateRoomResponse"}), resp)
                    return response(_id, 200, res)
                end
            else
                log.log("{http_api:create_room} gps error room_id[%s], uid[%s], location[%s]", data.room_id, data.owner, info.location or "")
                resp.code = const_code.ROOM_GPS_WARNING
                local res = protobuf.encode(table.concat({const_game.PB_NAMESPACE, ".CreateRoomResponse"}), resp)
                return response(_id, 200, res)
            end
        end

        local room_server = skynet.newservice("room_server", data.room_uuid)
        skynet.call(room_server, "lua", "start", data)
        resp.code = const_code.SUCESS
    end
    local res = protobuf.encode(table.concat({const_game.PB_NAMESPACE, ".CreateRoomResponse"}), resp)
    response(_id, 200, res)
end

---web解散房间
function M.web_dismiss(_id, _url_query, _post_body, _addr)
    local resp = {code=const_code.FAILURE}
    local ok, data = pcall(protobuf.decode, table.concat({const_game.PB_NAMESPACE, ".DismissRoomWebRequest"}), _post_body)
    if ok then
        local room_server = skynet.call(".room_mgr_server", "lua", "get_room_serve", data.room_id)
        if not room_server then
            resp.code = const_code.ROOM_NOT_EXIST
        else
            local rs = skynet.call(room_server, "lua", "web_dismiss_room")
            if rs.code == const_code.SUCESS then
                resp.code = 0 --解散成功
            else
                resp.code = 1 --解散失败
            end
        end
    end
    local res = protobuf.encode(table.concat({const_game.PB_NAMESPACE, ".DismissRoomWebResponse"}), resp)
    response(_id, 200, res)
end

---查询桌子状态
function M.table_status(_id, _url_query, _post_body, _addr)
    local resp = {}
    local ok, data = pcall(protobuf.decode, table.concat({const_game.PB_NAMESPACE, ".TableStatusQueryRequest"}), _post_body)
    if ok then
        local room_server = skynet.call(".room_mgr_server", "lua", "get_room_serve", data.room_id)
        if not room_server then
            resp.code = const_code.ROOM_NOT_EXIST
        else
            resp = skynet.call(room_server, "lua", "table_status")
        end
    end
    response(_id, 200, protobuf.encode(table.concat({const_game.PB_NAMESPACE, ".TableStatusQueryResponse"}), resp))
end

function M.customize_cards(_id, _url_query, _post_body, _addr)
    local resp = "配牌成功！"
    local ok, data = pcall(cjson.decode, _post_body)
    if ok then
        local card_tb = {}

        if data.card1 == "" or data.card2 == "" or data.card3 == "" or data.card4 == "" then
            sharetable.loadtable ("customize_cards", card_tb)
            return response(_id, 200, "玩家的牌为空，视为关闭配牌！")
        end
        card_tb.cards = {}
        card_tb.cards[1] = string.split(data.card1, ",")
        card_tb.cards[2] = string.split(data.card2, ",")
        card_tb.cards[3] = string.split(data.card3, ",")
        card_tb.cards[4] = string.split(data.card4, ",")
        card_tb.flag_card = tonumber(card_tb.cards[1][1])
        --if tonumber(card_tb.cards[1][1]) ~= tonumber(card_tb.cards[2][1]) and tonumber(card_tb.cards[1][1]) ~= tonumber(card_tb.cards[3][1])
        --        and tonumber(card_tb.cards[1][1]) ~= tonumber(card_tb.cards[4][1]) then
        --    return response(_id, 200, "第一张牌错误！第一张牌必须能找出队友！")
        --end
        --if #card_tb.cards[1] < 3 or #card_tb.cards[2] < 3 or #card_tb.cards[3] < 3 or #card_tb.cards[4] < 3 then
        --    return response(_id, 200, "手牌张数太少！每人手牌不少于3张！")
        --end
        for _, cards in pairs(card_tb.cards) do
            for i, v in pairs(cards) do
                cards[i] = tonumber(v)
            end
        end
        sharetable.loadtable ("customize_cards", card_tb)
    else
        resp = "数据错误！"
    end
    response(_id, 200, resp)
end

---查询桌子数量
function M.query_rooms(_id, _url_query, _post_body, _addr)
    local rooms_tb = skynet.call(".room_mgr_server", "lua", "get_all_rooms")
    local resp = {rooms={}}
    local total = 0
    for i, v in pairs(rooms_tb) do
        resp.rooms[i] = skynet.address(v)
        total = total + 1
    end
    resp.num = total
    response(_id, 200, cjson.encode(resp))
end

--清理房间服务(用于内部异常处理)
function M.clear_room(_id, _url_query, _post_body, _addr)
    local resp = {}
    if utils.get_ip(_addr) ~= "127.0.0.1" then
        resp.msg = "ILLEGAL REQUEST"
        return response(_id, 200, cjson.encode(resp))
    end
    if not _url_query.room_id or _url_query.room_id == "" then
        resp.msg = "PARAMETER ERROR"
        return response(_id, 200, cjson.encode(resp))
    end
    local room_id = tonumber(_url_query.room_id)
    local room_server = skynet.call(".room_mgr_server", "lua", "get_room_serve", room_id)
    if not room_server then
        resp.msg = "ROOM_NOT_EXIST"
    else
        local rs = skynet.call(room_server, "lua", "web_dismiss_room")
        if rs.code == const_code.SUCESS then
            resp.msg = "SUCCESS" --解散成功
        else
            resp.msg = "FAIL" --解散失败
        end
    end
    response(_id, 200, cjson.encode(resp))
end

function M.test(_id, _url_query, _post_body, _addr)
    local card_type = require "games.card_type"
    local card_helper = require "games.card_helper"

    local rs
    --rs = card_type.get_type({0x16}, 8)
    --dump(rs, "单张")
    --rs = card_type.get_type({0x16, 0x16}, 8)
    --dump(rs, "对子")
    --rs = card_type.get_type({0x2e,0x2d,0x2d}, 8)
    --dump(rs, "边三轮")
    --rs = card_type.get_type({0x2e,0x2e,0x2d}, 4)
    --dump(rs, "边三轮")
    --rs = card_type.get_type({0x1e,0x1e, 0x1d,0x1d,0x1c,0x1c,0x1b,0x1b,0x1a,0x1a,0x19,0x19,0x18,0x18,0x17,0x17,0x16}, 8)
    --dump(rs, "主多边三轮")
    --rs = card_type.get_type({0x1e,0x1e, 0x1d,0x1d,0x1c,0x1c,0x1b,0x1b,0x1a,0x1a,0x19,0x19,0x18,0x18,0x16}, 4)
    --dump(rs, "副多边三轮")

    --rs = card_type.get_type({0x1,0x1, 0x2,0x2}, 8)
    --dump(rs, "红王蓝王拖拉机")
    --rs = card_type.get_type({0xe,0xe, 0xf,0xf}, 8)
    --dump(rs, "大王小王拖拉机")
    --rs = card_type.get_type({0x17,0x17, 0x47,0x47}, 1)
    --dump(rs, "正7副7拖拉机")
    --rs = card_type.get_type({0x16, 0x16, 0x19,0x19, 0x18,0x18}, 4)
    --dump(rs, "负拖拉机")
    --rs = card_type.get_type({0x16, 0x16, 0x19,0x19, 0x18,0x18, 0x17,0x17}, 8)
    --dump(rs, "主拖拉机")

    --rs = card_helper.can_discard({0xf, 0xe, 0x38}, {{card=0xe},{card=0xf}}, {0x15,0x15}, {t=card_type.type.t_2,l=1,n=1},16)
    --dump(rs, "rs")

    --dump(card_helper.card_is_lord({0x1, 0xe,0xf,0x2, 0x17, 0x29}, 8))

    --local rs = card_helper.can_discard( { 0x17,0x37,0x47,0x47, 0x2a, 0x2a, 0x18, 0x19, 0x23, 0x33, 0x26}, {{card=0x2a},{card=0x2a},{card=0x23}}, {0x2e,0x2e,0x2d},{t=card_type.type.t_aak,l=0,n=1},8)
    --dump(rs, "rs")

    --local rs = card_helper.get_robot_cards(4, { 0x17,0x37,0x47,0x47, 0x2a, 0x2c, 0x18, 0x19, 0x23, 0x33}, {t=card_type.type.t_2n,l=1,n=2}, {0x2e,0x2e,0x2d,0x2d})
    --dump(card_helper.cards_tostring(rs), "rs")

    response(_id, 200, "test")
end

return M