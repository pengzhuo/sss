---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by b_ree.
--- DateTime: 2019/2/19 11:08
---
local skynet = require "skynet"
local cjson = require "cjson"
local crypt = require "skynet.crypt"

local redis_server_num = skynet.getenv("redis_snlua_num")
local mysql_server_num = skynet.getenv("mysql_snlua_num")

local M = {}

math.randomseed( table.concat({tostring(os.time()):reverse():sub(1, 7), skynet.self()}) )
local char_tbl = {"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"}

function M.get_random(min, max)
    return math.random(min,max)
end

--[[--

深度克隆一个值

~~~ lua

-- 下面的代码，t2 是 t1 的引用，修改 t2 的属性时，t1 的内容也会发生变化
local t1 = {a = 1, b = 2}
local t2 = t1
t2.b = 3    -- t1 = {a = 1, b = 3} <-- t1.b 发生变化

-- clone() 返回 t1 的副本，修改 t2 不会影响 t1
local t1 = {a = 1, b = 2}
local t2 = clone(t1)
t2.b = 3    -- t1 = {a = 1, b = 2} <-- t1.b 不受影响

~~~

@param mixed object 要克隆的值

@return mixed

]]
function M.clone(object)
    local lookup_table = {}
    local function _copy(object)
        if type(object) ~= "table" then
            return object
        elseif lookup_table[object] then
            return lookup_table[object]
        end
        local new_table = {}
        lookup_table[object] = new_table
        for key, value in pairs(object) do
            new_table[_copy(key)] = _copy(value)
        end
        return setmetatable(new_table, getmetatable(object))
    end
    return _copy(object)
end

--转16进制 字母小写
function M.to_hex(str)
    return ({str:gsub(".", function(c) return string.format("%02x", c:byte(1)) end)})[1]
end

--随机生成指定长度字符
function M.create_nonstr(len)
    len = len or 8
    local str = ""
    while string.len(str) < len do
        local index = M.get_random(1, 62)
        str =  str..char_tbl[index]
    end
    return str
end

--随机乱序数组table
function M.random_array(arr)
    local tmp, index
    local rdsize = #arr
    for i=1, #arr-1 do
        index = math.random(i, rdsize)
        if i ~= index then
            tmp = arr[index]
            arr[index] = arr[i]
            arr[i] = tmp
        end
    end
    return arr
end

function M.guid(str)
    local tb={}
    for i=1,32 do
        tb[i] = char_tbl[M.get_random(1,36)]
    end
    local sid=table.concat(tb)
    if str and str ~= "" then
        return string.format('%s-%s-%s-%s-%s%s',
                string.sub(sid,1,8),
                string.sub(sid,9,12),
                string.sub(sid,13,16),
                string.sub(sid,17,20),
                string.sub(sid,21,26),
                str
        )
    else
        return string.format('%s-%s-%s-%s-%s',
                string.sub(sid,1,8),
                string.sub(sid,9,12),
                string.sub(sid,13,16),
                string.sub(sid,17,20),
                string.sub(sid,21,32)
        )
    end

end

function M.format_time(t, is_time)
    if is_time then
        return os.date("%Y-%m-%d %H:%M:%S",t)
    else
        return os.date("%Y-%m-%d",t)
    end
end

---@param _future_days number
---@param _future_hour number
---@return  number
function M.get_time(_future_days, _future_hour)
    --默认参数为当天0点
    local future_hour = _future_hour or 0
    local future_days = _future_days or 0
    local cur_timestamp = os.time()
    local one_hour_timestamp = 24*60*60
    local temp_time = cur_timestamp + one_hour_timestamp * future_days
    local temp_date = os.date("*t", temp_time)

    local resultTime = os.time({year=temp_date.year, month=temp_date.month, day=temp_date.day, hour=future_hour})
    return resultTime
end

function M.decode(str, path)
    local str = str
    if not path then
        str = str:gsub('+', ' ')
    end
    return (str:gsub("%%(%x%x)", function(c)
        return string.char(tonumber(c, 16))
    end))
end

function M.encode(str)
    return (str:gsub("([^A-Za-z0-9%_%.%-%~])", function(v)
        return string.upper(string.format("%%%02x", string.byte(v)))
    end))
end

--api接口的签名
function M.sign(tb, key)
    local keys = table.keys(tb)
    table.sort(keys, function(a,b) return (a < b) end)
    local args = {}
    for _, v in ipairs(keys) do
        if v ~= "sign" then
            args[#args+1] = tb[v]
        end
    end
    args[#args+1] = key
    return M.to_hex(crypt.sha1(table.concat(args)))
end

--解析客户端ip(192.168.1.10:89878)
function M.get_ip(ip_str)
    local pos = string.find(ip_str, ":")
    if pos > 0 then
        return string.sub(ip_str, 1, pos-1)
    end
    return ip_str
end

--向指定玩家发消息
function M.send_msg(aid, code, msg)
    local agent = skynet.call(".agent_mgr", "lua", "get", aid)
    if agent then
        skynet.send(agent, "lua", "send", code, msg)
    end
end

function M.insert_sql(tab_name, data)
    local values = {}
    for k, v in pairs(data) do
        values[#values + 1] = table.concat({"'", v, "'"})
    end
    return table.concat({"insert into ", tab_name, " (", table.concat(table.keys(data), ","), ") values (", table.concat(values, ","), ")"})
end

function M.update_sql(tab_name, data, where)
    if not where or where == "" then
        error(" Illegal parameter: where")
    end
    local params
    for k, v in pairs(data) do
        if not params then
            params = ""
        else
            params = table.concat({params, ", "})
        end
        params = table.concat({params, k, "='", v, "'"})
    end
    return table.concat({"update ", tab_name, " set ", params, " where ", where})
end

--根据参数路由到不同的Redis服务，防止单服务过载
function M.redis_route()
    local route_id = math.random(1, redis_server_num)
    return table.concat({".db_redis_", route_id})
end

--根据参数路由到不同的MySQL服务，防止单服务过载
function M.mysql_route()
    local route_id = math.random(1, mysql_server_num)
    return table.concat({".mysql_slave_", route_id})
end

--打包成redis hset 格式
function M.pack_hmset(_key, _tb)
    local ret = {_key}
    for k, v in pairs(_tb) do
        local s = #ret
        ret[s + 1] = k
        ret[s + 2] = v
    end
    return ret
end

--将hgetall读到的数据，解析成方便的table
function M.unpack_hgetall(_hgetall_tb)
    local list = {}
    if not _hgetall_tb then
        return list
    end
    local size = #_hgetall_tb / 2
    for i = 1, size do
        list[_hgetall_tb[i*2 - 1]] = _hgetall_tb[i*2]
    end
    return list
end

--返回 key为 user_nick avatar_url ...的用户基础信息
function M.get_base_user_info(_user_info)
    local base_info = {
        aid = _user_info.aid,
        uid = tostring(_user_info.aid),
        avatar_url = _user_info.uface,
        user_nick = _user_info.unick
    }
    return base_info
end

--返回 key为 unick uface ...的用户基础信息
function M.get_base_user_info_ex(_user_info)
    local base_info = {
        aid = _user_info.aid,
        uid = tostring(_user_info.aid),
        uface = _user_info.uface,
        unick = _user_info.unick
    }
    return base_info
end

---防注入处理字符串
function M.addslashes(_str)
    return string.gsub(_str, "['%%\r\"\n\\\0]", "")
end

---替换转义符，用于写入mysql反斜杠被自动删除的问题
function M.replace_escapes(_str)
    local str = string.gsub(_str, [[\]], [[\\]])
    return str
end

---得到含中文字符的长度
function M.utf8len(input)
    local len  = string.len(input)
    local left = len
    local cnt  = 0
    local arr  = {0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc}
    while left ~= 0 do
        local tmp = string.byte(input, -left)
        local i   = #arr
        while arr[i] do
            if tmp >= arr[i] then
                left = left - i
                break
            end
            i = i - 1
        end
        cnt = cnt + 1
    end
    return cnt
end

---过滤emoji字符
function M.filter_emoji(str)
    if not str then
        return str
    end
    local new = {}
    for _, c in utf8.codes(str) do
        if c < 55296 then
            new[#new+1] = utf8.char(c)
        end
    end
    return table.concat(new)
end

-- 从长度为m的数组中选n个元素的组合
function M.permutation(atable, n)
    local t1 = skynet.hpc()
    if n > #atable then
        return {}
    end

    local len = #atable
    local meta = {}
    -- init meta data
    for i=1, len do
        if i <= n then
            table.insert(meta, 1)
        else
            table.insert(meta, 0)
        end
    end

    local result = {}

    -- 记录一次组合
    local tmp = {}
    for i=1, len do
        if meta[i] == 1 then
            table.insert(tmp, atable[i])
        end
    end
    table.insert(result, tmp)

    while true do
        -- 前面连续的0
        local zero_count = 0
        for i=1, len-n do
            if meta[i] == 0 then
                zero_count = zero_count + 1
            else
                break
            end
        end
        -- 前m-n位都是0，说明处理结束
        if zero_count == len-n then
            break
        end

        local idx
        for j=1, len-1 do
            -- 10 交换为 01
            if meta[j]==1 and meta[j+1] == 0 then
                meta[j], meta[j+1] = meta[j+1], meta[j]
                idx = j
                break
            end
        end
        -- 将idx左边所有的1移到最左边
        local k = idx-1
        local count = 0
        while count <= k do
            for i=k, 2, -1 do
                if meta[i] == 1 then
                    meta[i], meta[i-1] = meta[i-1], meta[i]
                end
            end
            count = count + 1
        end

        -- 记录一次组合
        local tmp = {}
        for i=1, len do
            if meta[i] == 1 then
                table.insert(tmp, atable[i])
            end
        end
        table.insert(result, tmp)
    end
    --print("permutation 耗时:", (skynet.hpc() - t1) / 1000000, "ms")
    return result
end

return M