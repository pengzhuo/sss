---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by b_ree.
--- DateTime: 2019/11/5 11:26
---

local log = require "log"
require "functions"

local STATUS = {
    init = 0, --初始化
    ready = 1, --准备
    settle = 2, --小结算
}

---@class Player
local Player = class("Player")

---@protected
function Player:ctor(_uid, _agent, _seat, _uinfo)
    self.m_ip = ""
    self.m_uid = _uid
    self.m_agent = _agent
    self.m_uinfo = _uinfo
    self.m_seat = _seat
    self.m_status = STATUS.init --玩家状态
    self.m_online = 1 --在线状态 0离线; 1在线
    self.m_offline_time = 0 --离线时间
    self.m_total_score = 0 --玩家当前总积分（积分模式下玩家的总分）
    self.m_table_score = 0 --本次牌局的输赢分
    self.m_round_score = 0 --小局的输赢分
    self.m_hand_cards = {} --手牌
    self.m_rob_score = 0 --叫分
    self.m_discards = {} --打出去的牌
    self.m_action_list = {} --玩家操作记录

    self.m_discard_status = -1 -- -1不是该玩家出牌; 0首出; 1管不起; 2管得起

    self.m_top_score = nil -- 大结算单局最高分
    self.m_win_cnt = 0  -- 大结算赢牌次数
    self.m_lost_cnt = 0 -- 大结算输牌次数
    self.m_top_level = 0 -- 大结算最高等级

    self.m_is_robot = false -- 是否托管状态
    self.m_robot_timer = 0 -- 托管定时器
    self.m_action_seq = 0 -- 玩家单局有效操作的唯一序号，用于托管状态判断
    self.m_join_time = 0 -- 玩家加入房间时间
    self.m_pickup_point = 0 --玩家捡分
end

---@public 新的一局数据初初化处理
function Player:next_round_init_data()
    self.m_round_score = 0
    self.m_hand_cards = {}
    self.m_rob_score = 0
    self.m_action_list = {}
    self.m_robot_timer = 0
    self.m_action_seq = 0

    self.m_pickup_point = 0
end

--玩家对应agent地址
---@public
function Player:get_agent()
    return self.m_agent
end

--玩家当前分数(总分)
---@public
function Player:get_total_score()
    return self.m_total_score
end

---@public 设置玩家当前分数(总分)
function Player:set_total_score(_score)
    self.m_total_score = _score
end

---@public 玩家本房间输赢分数
function Player:get_table_score()
    return self.m_table_score
end

---@public 玩家本房间输赢分数
function Player:set_table_score(_score)
    self.m_table_score = _score
end

---@public 获取玩家的当前牌局输赢分数
function Player:get_round_score()
    return self.m_round_score
end

---@public 设置玩家的当前牌局输赢分数
function Player:set_round_score(_score)
    self.m_round_score = _score
    self.m_table_score = self.m_table_score + _score
    self.m_total_score = self.m_total_score + _score
    if not self.m_top_score or _score > self.m_top_score then
        --记录单局最高分
        self.m_top_score = _score
    end
    if _score < 0 then
        self:add_lost_cnt()
    elseif _score > 0 then
        self:add_win_cnt()
    end
end

function Player:get_top_level()
    return self.m_top_level
end

function Player:set_top_level(level)
    if self.m_top_level < level then
        self.m_top_level = level
    end
end

--玩家座位号
---@public
function Player:get_seat()
    return self.m_seat
end

--玩家uid
---@public
function Player:get_uid()
    return self.m_uid
end

---@public 得到玩家基本信息
function Player:get_uinfo()
    return self.m_uinfo
end

---@public 得到玩家状态
function Player:get_status()
    return self.m_status
end

---@public 设置玩家状态
function Player:set_status(_status)
    self.m_status = _status
end


---@public 得到玩家在线状态
function Player:get_online()
    return self.m_online
end

---@public 得到玩家离线时间戳
function Player:get_offline_time()
    return self.m_offline_time
end

---@public 得到手牌
function Player:get_hand_cards()
    return self.m_hand_cards
end

---@public 添加一张手牌
function Player:add_one_hand_card(_card)
    self.m_hand_cards[#self.m_hand_cards+1] = _card
end

---@public 从手牌中移除
---@param _cards table
---@return table 当前手牌
function Player:remove(_cards)
    for _, v in pairs(_cards) do
        table.removebyvalue(self.m_hand_cards, v)
    end
    return self.m_hand_cards
end

---@public 设置玩家手牌
function Player:set_hand_cards(_cards)
    self.m_hand_cards = _cards
    self:sort_hand_cards()
end

---@public 打出牌，从手牌中移除
---@param _cards table
---@return table 当前手牌
function Player:discard(_cards)
    for _, v in pairs(_cards) do
        table.removebyvalue(self.m_hand_cards, v)
    end
    self.m_discards = _cards --打出去的牌
    self:set_discard_status(-1) --玩家出牌完毕，标记当前出牌状态
    return self.m_hand_cards
end

---@private 手牌排序
function Player:sort_hand_cards()
    table.sort(self.m_hand_cards, function (a, b)
        return a < b
    end)
end

---@public
function Player:online(_agent)
    log.log("{Player:online}uid[%d] 上线 agent[%d]", self.m_uid, _agent)
    self.m_agent = _agent
    self.m_online = 1
    self.m_offline_time = 0
end

---@public
function Player:offline(_agent)
    log.log("{Player:offline}uid[%d] 离线 agent[%d]", self.m_uid, _agent)
    if self.m_agent == _agent then
        self.m_online = 0
        self.m_offline_time = os.time()
    end
end

---@public 得到玩家的叫分
function Player:get_rob_score()
    return self.m_rob_score
end

---@public 设置玩家的叫分
function Player:set_rob_score(_score)
    self.m_rob_score = _score
end

---@public 得到是否报听
function Player:get_ting()
    local t = table.nums(self.m_hand_cards)
    if t > 2 or t == 0 then
        return false
    else
        return t
    end
end

---@public 得到打出去的牌(只有最后一次)
function Player:get_discards()
    return self.m_discards
end

---@public 大结算单局最高分
function Player:get_top_score()
    return self.m_top_score
end

---@public 大结算赢牌次数
function Player:get_win_cnt()
    return self.m_win_cnt
end
---@public 大结算赢牌次数加1
function Player:add_win_cnt()
    self.m_win_cnt = self.m_win_cnt + 1
end

---@public 大结算输牌次数
function Player:get_lost_cnt()
    return self.m_lost_cnt
end
---@public 大结算输牌次数加1
function Player:add_lost_cnt()
    self.m_lost_cnt = self.m_lost_cnt + 1
end

---@public 得到出牌状态 -1不是该玩家出牌; 0首出; 1管不起; 2管得起
function Player:get_discard_status()
    return self.m_discard_status
end

---@public 设置出牌状态 -1不是该玩家出牌; 0首出; 1管不起; 2管得起
function Player:set_discard_status(status)
    self.m_discard_status = status
end

---@public 得到托管状态
function Player:get_is_robot()
    return self.m_is_robot
end

---@public 设置托管状态
function Player:set_is_robot(_is_robot)
    self.m_robot_timer = 0
    self.m_is_robot = _is_robot
end

---@public 记录玩家的操作
function Player:do_action()
    self.m_robot_timer = 0
    self.m_action_seq = self.m_action_seq + 1
end

---@public 得到玩家操作的流水id(用于托管的操作判定)
function Player:get_action_seq()
    return self.m_action_seq
end

---@public 托管计时器加1
function Player:add_robot_time()
    self.m_robot_timer = self.m_robot_timer + 1
    --if self:get_online() == 0 then
    --    --如果为离线状态，则进入托管的计时器额外加上离线时长
    --    local offline_time = os.time() - self:get_offline_time()
    --    return self.m_robot_timer + offline_time
    --end
    return self.m_robot_timer
end

---@public 设置托管计时器时间
function Player:set_robot_time(_t)
    self.m_robot_timer = _t
end
---@public 得到托管计时器时间
function Player:get_robot_time()
    return self.m_robot_timer
end

---@public 设置玩家客户端IP地址
function Player:set_ip(_ip)
    self.m_ip = _ip
end
---@public 得到玩家客户端IP地址
function Player:get_ip()
    return self.m_ip
end

---@public 设置玩家加入房间时间
function Player:set_join_time(_time)
    self.m_join_time = _time
end
---@public 得到玩家加入房间时间
function Player:get_join_time()
    return self.m_join_time
end


---@public 得到玩家捡分
function Player:get_pickup_point()
    return self.m_pickup_point
end
---@public 玩家捡分
function Player:add_pickup_point(_point)
    self.m_pickup_point = self.m_pickup_point + _point
end

---@public 得到当前手牌可叫主的颜色
---@return number 从高位到低位 1111 黑,红,梅,方
function Player:get_lord_color()
    local weight = {8,4,2,1}
    local list = {}
    local color, c = 0
    for _, v in pairs(self.m_hand_cards) do
        if (v & 0xf) == 7 then
            c = v >> 4
            if not table.indexof(list, c) then
                color = color + weight[c]
                list[#list+1] = c
            end
        end
    end
    return color
end

---@public 得到当前手牌可以反主的颜色
---@return number 从高位到低位 11111111 红花,黑花,大王,小王,黑,红,梅,方
function Player:get_rebel_color(_comp_color, _fandahua)
    local weight = {128,64,32,16,8,4,2,1}
    local list = {0,0,0,0,0,0,0,0}
    local rs, color = 0, 0
    for _, v in pairs(self.m_hand_cards) do
        if (v & 0xf) == 2 and (v >> 4) == 0 then --红花
            list[1] = list[1] + 1
        elseif (v & 0xf) == 1 and (v >> 4) == 0 then --黑花
            list[2] = list[2] + 1
        elseif (v & 0xf) == 15 and (v >> 4) == 0 then
            list[3] = list[3] + 1
        elseif (v & 0xf) == 14 and (v >> 4) == 0 then
            list[4] = list[4] + 1
        elseif (v & 0xf) == 7 then
            color = v >> 4
            if color == 1 then
                list[5] = list[5] + 1
            elseif color == 2 then
                list[6] = list[6] + 1
            elseif color == 3 then
                list[7] = list[7] + 1
            elseif color == 4 then
                list[8] = list[8] + 1
            end
        end
    end
    if _fandahua and _comp_color == weight[1] and list[8] == 2 then
        return 1 --方块7反大花
    end
    for i, v in pairs(list) do
        if v == 2 then
            if not _comp_color or (_comp_color and weight[i] > _comp_color) then
                rs = rs + weight[i]
            end
        end
    end
    return rs
end


function Player:serialize()
    local tb = {}
    local ignore = {}
    for k, v in pairs(self) do
        if string.sub(k,1, 2) == "m_" and not table.indexof(ignore, k) then
            tb[k] = v
        end
    end
    return tb
end

function Player:unserialize(_data)
    for k, v in pairs(_data) do
        self[k] = v
    end
end

return Player