---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by b_ree.
--- DateTime: 2019/11/6 9:23
---

local skynet = require "skynet"
local log = require "log"
local cjson = require "cjson"
local utils = require "utils"
local protobuf = require "pb"
local crypt = require "skynet.crypt"
local const_code = require "const_code"
local const_game = require "const_game"
local const_cmd = require "const_cmd"
local http = require "http"
local Player = require "player"
local room_model = require "room_model"
local const_proto = require "const_proto"
require "functions"

cjson.encode_sparse_array(true)
local report_num_max = 10 --HTTP report 错误重试次数

---@class RoomBase
local RoomBase = class("RoomBase")

function RoomBase:ctor(_room_info)
    self.m_room_id = _room_info.room_id
    self.m_room_uuid = _room_info.room_uuid
    self.m_room_owner = tonumber(_room_info.owner)
    if type(_room_info.kwargs) == "table" then
        self.m_room_kwargs = _room_info.kwargs
    else
        self.m_room_kwargs = cjson.decode(_room_info.kwargs)
    end
    --dump(self.m_room_kwargs, "self.m_room_kwargs")
    self.m_club_setting = self.m_room_kwargs.club_setting and cjson.decode(self.m_room_kwargs.club_setting) or {}
    self.m_club_id = self.m_room_kwargs.club  --俱乐部/联盟id
    self.m_start_time = os.time() --游戏开始时间
    self.m_end_time = 0 --游戏结束时间

    self.m_max_player = self.m_room_kwargs.chairs    --游戏最多允许人数
    self.m_player_list = {}  --房间内玩家列表
    self.m_seat_list = {}    -- 座位列表{uid1=1,uid2=2,uid3=3}
    self.m_rest_cards = 54   --剩余牌数
    self.m_max_rounds = self.m_room_kwargs.max_rounds --最大局数
    self.m_current_round = 1 --当前局数

    ---@class statemachine
    self.m_fsm = nil
    self.m_is_start = false --标记游戏是否已开局
    self.m_is_freeze = false --游戏是否为冻结状态
    self.m_room_status = 0 --房间状态
    self.m_timer = 0 --计时器
    self.m_vote_list = {} -- 解散房间投票列表
    self.m_voting = false --是否投票中，如果是，则该值为发起投票人的uid
    self.m_vote_timer = const_game.VOTE_TIME --投票计时器
    self.m_dismiss_code = 0 --房间解散标识码

    self.m_replay = "" --回放数据
end

function RoomBase:init()
    skynet.fork(function ()
        while not self.m_is_start do
            skynet.sleep(100)
            self.m_timer = self.m_timer + 1
            if self.m_timer >= const_game.ROOM_AUTO_DISMISS_TIME then
                local code = self:do_dismiss_room(const_code.DISMISS_ROOM_CODE.TIMEOUT)
                if code == const_code.SUCESS then
                    local resp = {}
                    resp.code = const_code.SUCESS
                    resp.flag = 0 --0 房主发起解散 1 投票发起解散 2 管理员强制解散
                    self:send_msg(const_cmd.DISMISS_ROOM, resp)

                    log.log("房间[%d][%d]秒未开始，自动解散成功！", self.m_room_id, self.m_timer)
                else
                    log.log("房间[%d][%d]秒未开始，自动解散失败！", self.m_room_id, self.m_timer)
                end
            end
        end
    end)
end

---@protected 大结算，子类必须实现该方法
function RoomBase:big_settle(_code)
    assert(false,"Subclasses must implement 'big_settle' method!")
end

---@protected 重连，子类必须实现该方法
---@param _uid, number
function RoomBase:reconnect(_uid)
    assert(false,"Subclasses must implement 'reconnect' method!")
end

---@protected 保存快照，子类必须实现该方法
---@param _remove_uid, number 需要移除的Player
function RoomBase:snapshot(_remove_uid)
    assert(false,"Subclasses must implement 'snapshot' method!")
end

---@protected 删除快照，子类必须实现该方法
function RoomBase:del_snapshot()
    if const_game.SNAPSHOT then
        self.m_snapshot_apply = false
        room_model.del_room_key(self.m_room_id)
    end
end

---@protected  房间是否已满
function RoomBase:room_is_full()
    return table.nums(self.m_player_list) >= self.m_max_player
end

---@protected 是否为积分模式
function RoomBase:is_score_mode()
    return self.m_club_setting.club_type == 2
end

---@protected 积分是否不足
function RoomBase:is_score_less(_score)
    return self:is_score_mode() and self.m_club_setting.score_under and _score <= self.m_club_setting.score_under
end

---@protected 添加玩家player对象
function RoomBase:add_player(_uid, _pobj)
    self.m_player_list[_uid] = _pobj
end

---@protected 根据uid得到已加入房间的玩家player对象
function RoomBase:remove_player(_uid)
    self:clear_seat(_uid)
    self.m_player_list[_uid] = nil
end

---@protected 根据uid得到已加入房间的玩家player对象
function RoomBase:get_player(_uid)
    return self.m_player_list[_uid]
end

---@protected 根据座号得到已加入房间的玩家player对象
function RoomBase:get_player_by_seat(_seat)
    for _, obj in pairs(self.m_player_list) do
        if obj:get_seat() == _seat then
            return obj
        end
    end
end

---@protected 根据座号得到已加入房间的玩家uid
function RoomBase:get_uid_by_seat(_seat)
    for uid, obj in pairs(self.m_player_list) do
        if obj:get_seat() == _seat then
            return uid
        end
    end
end

---@protected 根据uid得到已加入房间的玩家的座号
function RoomBase:get_seat_by_uid(_uid)
    for uid, obj in pairs(self.m_player_list) do
        if uid == _uid then
            return obj:get_seat()
        end
    end
end

---@public
function RoomBase:get_fsm_state()
    return self.m_fsm:getState()
end

---@protected 得到下一个操作的座号
function RoomBase:get_next_seat(_seat)
    local next_seat
    if _seat == self.m_max_player then
        next_seat = 1
    else
        next_seat = _seat + 1
    end
    return next_seat
end

---@public
function RoomBase:online(_uid, _agent)
    if self.m_player_list then
        ---@type Player
        local player = self:get_player(_uid)
        player:online(_agent)
        self:reconnect(_uid)
        --广播在线状态
        local resp = {
            player = tostring(_uid),
            status = true
        }
        self:send_msg(const_cmd.ONLINE_STATUS, resp, nil, _uid)
    end
end

---@public
function RoomBase:offline(_uid, _agent)
    if self.m_player_list then
        local player = self:get_player(_uid)
        if player then
            player:offline(_agent)
        end
        --广播离线状态
        local resp = {
            player = tostring(_uid),
            status = false
        }
        self:send_msg(const_cmd.ONLINE_STATUS, resp, nil, _uid)
    end
end

---@protected  分配座位号
function RoomBase:assign_seat(_uid)
    local seat = 1
    while true do
        if not self.m_seat_list[seat] then
            break
        end
        seat = seat + 1
    end
    self.m_seat_list[seat] = _uid
    return seat
end
---@protected  清理座位号
function RoomBase:clear_seat(_uid)
    ---@type Player
    local p = self:get_player(_uid)
    if p then
        self.m_seat_list[p:get_seat()] = nil
    end
end

---@protected  @进入房间报告
function RoomBase:enter_report(_uid)
    local req = {
        code = const_code.SUCESS,
        app_id = const_game.APP_ID,
        game_type = const_game.GAME_ID,
        player = tostring(_uid),
        room_id = self.m_room_id,
        club_id = self.m_club_id or 0
    }
    local ok, data = http.post(table.concat({const_game.LOBBY_API_HOST, "/room/enter"}),
            protobuf.encode(table.concat({const_game.PB_NAMESPACE, ".EnterRoomWebResponse"}), req))
    if ok then
        local deok, rs = pcall(cjson.decode, data)
        if deok then
            if rs.code == const_code.SUCESS then
                log.log("{RoomBase:enter_report}上报进入房间成功. room_id[%d], uid[%d], score:[%d]", self.m_room_id, _uid, rs.score)
                return {code=const_code.SUCESS, score=rs.score}
            else
                log.log("{RoomBase:enter_report}上报进入房间完成. room_id[%d], uid[%d], code:[%d]", self.m_room_id, _uid, rs.code)
                return {code=rs.code}
            end
        else
            log.ding("{RoomBase:enter_report}上报进入房间响应数据错误. room_id[%d], uid[%d], response[%s]", self.m_room_id, _uid, data)
        end
    else
        log.ding("{RoomBase:enter_report}上报进入房间请求失败. request[%s]", cjson.encode(req))
    end
    return {code=const_code.FAILURE}
end

---@protected  @房间坐下报告
function RoomBase:seat_report(_uid)
    local resp = {code=const_code.FAILURE}
    local req = {
        code = const_code.SUCESS,
        app_id = const_game.APP_ID,
        game_type = const_game.GAME_ID,
        player = tostring(_uid),
        room_id = self.m_room_id,
        club_id = self.m_club_id or 0
    }
    local ok, data = http.post(table.concat({const_game.LOBBY_API_HOST, "/room/seat"}),
            protobuf.encode(table.concat({const_game.PB_NAMESPACE, ".EnterRoomWebResponse"}), req))
    if ok then
        local deok, rs = pcall(cjson.decode, data)
        if deok then
            if rs.code == const_code.SUCESS then
                log.log("{RoomBase:seat_report}上报房间坐下成功. room_id[%d], uid[%d]", self.m_room_id, _uid)
                resp.code = const_code.SUCESS
                return resp
            else
                log.log("{RoomBase:seat_report}上报房间坐下错误. code[%s], room_id[%d], uid[%d]", rs.code, self.m_room_id, _uid)
            end
        else
            log.ding("{RoomBase:seat_report}上报房间坐下响应错误. response[%s]", data)
        end
    else
        log.ding("{RoomBase:seat_report}上报房间坐下请求失败. request[%s]", cjson.encode(req))
    end
    return resp
end

---@protected  @退出房间报告
function RoomBase:exit_report(_uid)
    local resp = {code=const_code.FAILURE}
    local req = {
        code = const_code.SUCESS,
        app_id = const_game.APP_ID,
        game_type = const_game.GAME_ID,
        player = tostring(_uid),
        room_id = self.m_room_id,
        club_id = self.m_club_id or 0
    }

    local ok, data = http.post(table.concat({const_game.LOBBY_API_HOST, "/room/exit"}),
            protobuf.encode(table.concat({const_game.PB_NAMESPACE, ".ExitRoomWebResponse"}), req))
    if ok then
        local de_ok, de_rs = pcall(cjson.decode, data)
        if de_ok then
            if de_rs.code == const_code.SUCESS then
                log.log("{RoomBase:exit_report}上报退出房间成功. room_id[%s], uid[%s]", self.m_room_id, _uid)
                resp.code = const_code.SUCESS
                return resp
            else
                log.log("{RoomBase:exit_report}上报退出房间失败. room_id[%s], uid[%s], code[%s]", self.m_room_id, _uid, de_rs.code)
                resp.code = de_rs.code
                return resp
            end
        else
            log.log("{RoomBase:exit_report}上报退出房间响应数据错误. room_id[%s], uid[%s], response[%s]", self.m_room_id, _uid, data)
            resp.code = const_code.FAILURE
            return resp
        end
    else
        log.ding("{RoomBase:exit_report}上报退出房间请求失败. %s", cjson.encode(req))
        resp.code = const_code.FAILURE
        return resp
    end
    return resp
end

---@public 进入房间
function RoomBase:enter_room(_agent, _data, _ip)
    log.log("{RoomBase:enter_room} room_id[%d], uid[%d]", _data.room_id, _data.player)
    local resp = {code=const_code.FAILURE}
    local uid = tonumber(_data.player)

    if self.m_player_list == nil then
        return {code=const_code.ROOM_NOT_EXIST}
    end

    if self:get_player(uid) then
        --断线重连
        self:online(uid, _agent)
        return
    end

    if self:room_is_full() then
        resp.code = const_code.ROOM_IS_FULL  --房间已满
        return resp
    end
    if self.m_room_kwargs.ip == 1 and _ip and _ip ~= "" then --IP预警
        for _, v in pairs(self.m_player_list) do
            if v:get_ip() == _ip then
                resp.code = const_code.ROOM_IP_WARNING
                return resp
            end
        end
    end
    if self.m_room_kwargs.gps == 1 then --GPS预警
        local ok, info = pcall(cjson.decode, _data.info)
        if ok and type(info.location) == "table" then
            if table.nums(info.location) < 2 then
                resp.code = const_code.ROOM_GPS_WARNING
                return resp
            end
        else
            log.log("{room_base:enter_room} gps error room_id[%d], uid[%d], location[%s]", _data.room_id, uid, info.location or "")
            resp.code = const_code.ROOM_GPS_WARNING
            return resp
        end
    end

    local enter_rs = self:enter_report(uid)
    if enter_rs.code ~= const_code.SUCESS then
        --上报大厅进入房间失败
        resp.code = enter_rs.code
        return resp
    end
    local seat_rs = self:seat_report(uid)
    if seat_rs.code ~= const_code.SUCESS then
        --上报大厅进入房间失败
        resp.code = seat_rs.code
        return resp
    end

    local seat = self:assign_seat(uid)
    local uinfo = cjson.decode(_data.info)
    local player = Player.new(uid, _agent, seat, uinfo)
    player:set_ip(_ip)
    player:set_join_time(os.time())
    self:add_player(uid, player)
    player:set_total_score(enter_rs.score)

    self:snapshot() --快照

    --广播其他人进入房间
    local data = {
        code = const_code.SUCESS,
        player = tostring(player:get_uid()),
        seat = player:get_seat(),
        info = cjson.encode(player:get_uinfo()),
        score = self:is_score_mode() and player:get_total_score() or player:get_table_score(),
    }
    self:send_msg(const_cmd.ENTER_ROOM_OTHER, data, nil, uid)

    --玩家列表
    local plist = {}
    local p_item
    for _, pobj in pairs(self.m_player_list) do
        p_item = {
            seat = pobj:get_seat(),
            player = tostring(pobj:get_uid()),
            info = cjson.encode(pobj:get_uinfo()),
            status = pobj:get_status(),
            is_online = pobj:get_online(),
            total_score = self:is_score_mode() and pobj:get_total_score() or pobj:get_table_score(),
        }
        plist[#plist+1] = p_item
    end

    resp = {
        code = const_code.SUCESS,
        room_id = self.m_room_id,
        room_uuid = self.m_room_uuid,
        owner = tostring(self.m_room_owner),
        owner_info = self.m_room_kwargs.owner_info,
        kwargs = cjson.encode(self.m_room_kwargs),
        player = plist
    }
    return resp
end

---@public 玩家退出房间
function RoomBase:exit_room(_uid, _data)
    local resp = {}
    if self.m_is_start then --如果已经开局，则走投票解散房间流程
        self:dismiss_room(_uid, const_code.DISMISS_ROOM_CODE.VOTE)
        return
    end

    self:remove_player(_uid)

    resp = {
        code = const_code.SUCESS,
        player = tostring(_uid),
        --flag = 0 --0 完全离开 1 房间内离线
    }
    --离开房间广播
    self:send_msg(const_cmd.EXIT_ROOM, resp)

    self:exit_report(_uid)

    --如果玩家列表为空
    if not self.m_is_start and table.nums(self.m_player_list) == 0 then
        local code = self:do_dismiss_room(const_code.DISMISS_ROOM_CODE.OWNER)
        if code == const_code.SUCESS then
            log.log("{room_base:exit_room} room_id:[%s], Player list is empty, room dismiss success!", self.m_room_id)
        else
            log.log("{room_base:exit_room} room_id:[%s], Player list is empty, room dismiss failure!", self.m_room_id)
        end
    else
        --有人离开，必须写一次快照
        self:snapshot(_uid)
    end

    return resp
end

---@public 解散房间请求
function RoomBase:dismiss_room(_uid, _dismiss_code)
    local resp = {}
    local dismiss_code = _dismiss_code or const_code.DISMISS_ROOM_CODE.NORMAL --默认为正常解散

    if dismiss_code == const_code.DISMISS_ROOM_CODE.ADMIN then --管理员强制解散
        if self.m_is_start then
            if self.m_current_round > 1 then
                self:save_round_record()
            end
            self:big_settle(const_game.SETTLE_ROOM_STATUS.GM) --需要大结算
        end
        resp.code = self:do_dismiss_room(dismiss_code)
        resp.flag = 2 --0 房主发起解散 1 投票发起解散 2 管理员强制解散
        return resp
    end
    if not self.m_is_start then
        dismiss_code = const_code.DISMISS_ROOM_CODE.OWNER --房主提前解散
        resp.code = self:do_dismiss_room(dismiss_code)
        resp.flag = 0 --0 房主发起解散 1 投票发起解散 2 管理员强制解散
        return resp
    else
        --需要投票
        self.m_voting = _uid
        local vote_msg = {
            room_id = self.m_room_id,
            sponsor = tostring(_uid),
            expire_seconds = self.m_vote_timer
        }
        self:send_msg(const_cmd.SPONSOR_VOTE, vote_msg)

        --开始计时，如果未投票，计时结束则解散
        skynet.fork(function ()
            while self.m_voting and self.m_end_time == 0 do
                skynet.sleep(100)
                self.m_vote_timer = self.m_vote_timer - 1
                if self.m_vote_timer <= 0 then
                    if self.m_is_start then
                        if self.m_current_round > 1 then
                            self:save_round_record()
                        end
                        self:big_settle(const_game.SETTLE_ROOM_STATUS.Vote) --需要大结算
                    end
                    self:do_dismiss_room(const_code.DISMISS_ROOM_CODE.VOTE)
                end
            end
        end)

        return nil
    end
end

---@protected 执行解散房间
function RoomBase:do_dismiss_room(_dismiss_code)
    self.m_voting = false --防止投票定时器重复调用
    self.m_end_time = os.time()
    self.m_dismiss_code = _dismiss_code

    local score_list, statistic_list = {}, {}
    for uid, player in pairs(self.m_player_list) do
        score_list[tostring(uid)] = player:get_table_score()
        statistic_list[tostring(uid)] = {}
    end
    local req = {
        dismiss_code = _dismiss_code,
        app_id = const_game.APP_ID,
        game_type = const_game.GAME_ID,
        club_id = self.m_club_id,
        detail = "",
        et = os.time(),
        max_rounds = self.m_max_rounds,
        owner_uuid = tostring(self.m_room_owner),
        room_config = cjson.encode(self.m_room_kwargs),
        room_id = self.m_room_id,
        room_uuid = self.m_room_uuid,
        round = self.m_current_round,
        score = score_list,
        st = self.m_start_time,
        statistic = statistic_list
    }

    local post_json = cjson.encode(req)
    skynet.send(".game_task_server", "lua", "room_dismss_report", post_json, self.m_room_id)

    self:write_record() --写战绩
    self:del_snapshot() --删除快照
    self:room_destory()  --解散成功，清理工作
    return const_code.SUCESS
end

---@protected 房间服务清理和释放
function RoomBase:room_destory()
    for _, player in pairs(self.m_player_list) do
        skynet.send(player:get_agent(), "lua", "delay_close")
    end

    self.m_fsm = nil
    self.m_player_list = nil

    log.log("{room_base:room_destory}room[%s] server destory!", self.m_room_id)
    skynet.send(skynet.self(), "lua", "room_destory")
end

---@protected 游戏开局
function RoomBase:room_start()
    --写game_user_room表
    local sqls = {}
    for uid, player in pairs(self.m_player_list) do
        sqls[#sqls+1] = utils.insert_sql("game_user_room", {uid=uid, room_uuid=self.m_room_uuid, club_id=self.m_club_id, join_time=player:get_join_time()})
    end
    skynet.send(".mysql_master", "lua", "multi_query", sqls)

    --通知大厅服游戏开始
    local req = {
        code = 1,
        room_id = self.m_room_id,
        app_id = const_game.APP_ID,
        game_id = const_game.GAME_ID,
        club_id = self.m_club_id,
    }
    local report_num = report_num_max --失败最多重试次数
    skynet.fork(function ()
        while report_num > 0 do
            local ok, rs = http.post(table.concat({const_game.LOBBY_API_HOST, "/room/start"}),
                    protobuf.encode(table.concat({const_game.PB_NAMESPACE, ".StartRoomWebResponse"}), req))
            if ok then
                ok, rs = pcall( cjson.decode, rs )
                if ok or rs.code == 1 then
                    report_num = 0
                else
                    report_num = report_num - 1
                    log.ding("{RoomBase:room_start}上报大厅服start失败. %s", cjson.encode(req))
                end
            else
                report_num = report_num - 1
                log.ding("{RoomBase:room_start}上报大厅服start失败. %s", cjson.encode(req))
            end
            skynet.sleep(500)
        end
    end)

    self:snapshot_apply() --写快照申请
end

---@protected 局数更新
function RoomBase:round_update()
    local req = {
        code = 1,
        room_id = self.m_room_id,
        app_id = const_game.APP_ID,
        game_id = const_game.GAME_ID,
        club_id = self.m_club_id,
        round_id = self.m_current_round,
        players = {}
    }
    for uid, player in pairs(self.m_player_list) do
        req.players[#req.players+1] = {
            uid = tostring(uid),
            score = player:get_round_score()
        }
    end
    --通知大厅服局数更新

    local ok, rs = http.post(table.concat({const_game.LOBBY_API_HOST, "/room/round"}),
            protobuf.encode(table.concat({const_game.PB_NAMESPACE, ".RoundUpdateWebRequest"}), req))
    if ok then
        ok, rs = pcall( protobuf.decode, table.concat({const_game.PB_NAMESPACE, ".RoundUpdateWebResponse"}), crypt.base64decode(rs) )
        if ok and rs.code == 1 then
            return rs
        else
            log.ding("{RoomBase:round_update}上报大厅服round_update失败. %s", cjson.encode(req))
        end
    else
        log.ding("{RoomBase:round_update}上报大厅服round_update失败. %s", cjson.encode(req))
    end
    return false
end

---@public 玩家准备
function RoomBase:ready(_uid, _data)
    local resp = {}
    ---@type Player
    local pobj = self:get_player(_uid)
    pobj:ready()
    --广播准备状态
    resp = {player=tostring(_uid)}
    self:send_msg(const_cmd.READY, resp, nil, _uid)
    return resp
end

---@private 得到下一个出牌的座号
function RoomBase:get_next_discard_seat(_seat)
    local next_seat
    if _seat == self.m_max_player then
        next_seat = 1
    else
        next_seat = next_seat + 1
    end
    return next_seat
end

---@public 投票
function RoomBase:player_vote(_uid, _data)
    local resp = {}
    local agree = _data.flag or false
    resp.flag = agree
    resp.player = tostring(_uid)
    self:send_msg(const_cmd.PLAYER_VOTE, resp)
    if not agree then
        --有人拒绝，投票结束
        self.m_voting = false
        self.m_vote_timer = const_game.VOTE_TIME
        self.m_vote_list = {}
    else
        self.m_vote_list[_uid] = true
        if table.nums(self.m_vote_list) >= self.m_max_player - 1 then
            if self.m_is_start then
                if self.m_current_round > 1 then
                    self:save_round_record()
                end
                self:big_settle(const_game.SETTLE_ROOM_STATUS.Vote) --需要大结算
            end
            self:do_dismiss_room(const_code.DISMISS_ROOM_CODE.VOTE)
        end
    end
    return nil
end

---@public 大喇叭
function RoomBase:speaker(_uid, _data)
    local resp = {
        player = tostring(_uid),
        content = _data.content
    }
    self:send_msg(const_cmd.SPEAKER, resp)
    return nil
end

---@public 设置托管状态
function RoomBase:robot(_uid, _data)
    ---@type Player
    local playerObj = self:get_player(_uid)
    playerObj:set_is_robot(_data.status)

    local resp = {
        uid = tostring(_uid),
        status = _data.status
    }
    self:send_msg(const_cmd.ROBOT, resp)
    return nil
end

---@protected 初始化每局战绩数据
function RoomBase:init_replay()
    self.m_replay = ""
    local pack = string.pack(">B", const_game.GAME_ID)
    self.m_replay = self.m_replay .. pack

    --玩家列表
    local plist = {}
    local p_item
    for _, pobj in pairs(self.m_player_list) do
        p_item = {
            seat = pobj:get_seat(),
            player = tostring(pobj:get_uid()),
            info = cjson.encode(pobj:get_uinfo()),
            status = pobj:get_status(),
            is_online = pobj:get_online(),
            total_score = self:is_score_mode() and pobj:get_total_score() or pobj:get_table_score(),
        }
        plist[#plist+1] = p_item
    end

    local enter_resp = {
        code = const_code.SUCESS,
        room_id = self.m_room_id,
        room_uuid = self.m_room_uuid,
        owner = tostring(self.m_room_owner),
        owner_info = self.m_room_kwargs.owner_info,
        kwargs = cjson.encode(self.m_room_kwargs),
        player = plist
    }
    self:add_replay(const_cmd.ENTER_ROOM, enter_resp, 0)
end

---@protected 添加战绩指令
function RoomBase:add_replay(_cmd, _data, _uid)
    local pb = protobuf.encode(const_proto[_cmd].."Response", _data)
    local len = #pb
    local pack = string.pack(">i4I2i4c"..len, len, _cmd, _uid, pb)
    self.m_replay = self.m_replay .. pack
end

---@protected 每小局战绩详情写入到DB
function RoomBase:write_record_round(_room_uuid, _the_round, _score)
    local data = {
        room_uuid = _room_uuid,
        the_round = _the_round,
        procedure_log = crypt.base64encode(self.m_replay),
        score = cjson.encode(_score)
    }
    local sql = utils.insert_sql("game_record_detail", data)
    skynet.send(".mysql_master", "lua", "query", sql)
end

---@protected 大局战绩写入到DB
function RoomBase:write_record()
    if self.m_current_round > 1 then
        local data = {
            room_uuid = self.m_room_uuid,
            room_id = self.m_room_id,
            owner = self.m_room_owner,
            max_rounds = self.m_max_rounds,
            chairs = self.m_room_kwargs.chairs,
            chips = self.m_room_kwargs.chips,
            base_score = self.m_room_kwargs.base_score,
            aa = self.m_room_kwargs.aa,
            game_id = const_game.GAME_ID,
            club_id = self.m_club_id,
            config = utils.replace_escapes(cjson.encode(self.m_room_kwargs)),
            open_datetime = self.m_start_time,
            close_datetime = self.m_end_time,
            status = self.m_dismiss_code,
        }
        local users, statistic = {}, {}
        for uid, player in pairs(self.m_player_list) do
            users[tostring(uid)] = player:get_table_score()
            statistic[tostring(uid)] = {}
        end
        data.users = cjson.encode(users)
        data.statistic = cjson.encode(statistic)

        --dump(data, "data")
        local sql = utils.insert_sql("game_record", data)
        skynet.send(".mysql_master", "lua", "query", sql)
    end
end

---@protected room_server send_msg 方法的快捷方式
function RoomBase:send_msg(...)
    --log.log("send_msg cmd: [%d]", ({...})[1])
    skynet.send(skynet.self(), "lua", "send_msg", ...)
end

---@protected room_server send_msg_by_agent 方法的快捷方式
function RoomBase:send_msg_by_agent(...)
    --log.log("send_msg_by_agent cmd: [%d]", ({...})[1])
    return skynet.send(skynet.self(), "lua", "send_msg_by_agent", ...)
end

---@protected @得到一个托管玩家的uid，没有托管玩家返回nil
function RoomBase:get_room_robot_play()
    if self.m_player_list and next(self.m_player_list) then
        for _, player in pairs(self.m_player_list) do
            if player:get_is_robot() then
                return player
            end
        end
    end
    return nil
end

return RoomBase