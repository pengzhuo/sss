---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by b_ree.
--- DateTime: 2019/11/6 10:11
---

local skynet = require "skynet"
local log = require "log"
local statemachine = require "statemachine"
local cjson = require "cjson"
local utils = require "utils"
local sharetable = require "skynet.sharetable"
local const_code = require "const_code"
local const_game = require "const_game"
local const_cmd = require "const_cmd"
local RoomBase = require "room_base"
local card_type = require "games/card_type"
local card_helper = require "games/card_helper"
local Player = require "player"
local room_model = require "room_model"
require "functions"

local __RUNTIME = skynet.getenv("runtime")

---@class Room : RoomBase @define class Room extends RoomBase
local Room = class("Room", RoomBase)

function Room:ctor(_room_info, _recovery_info)
    --dump(_room_info, "_room_info")
    
    self.m_rob_list = {} --抢主/反主 列表 {{seat=1,flag=1},{seat=2,flag=1},{seat=3,flag=0},{seat=1,flag=1}}
    self.m_player_cards = {} --玩家起手手牌
    self.m_last_discard = {} --每回合最新打出的牌
    self.m_next_seat = -1   --下一个出牌的座号

    --托管相关参数，需根据客户端参数初始化
    self.m_robot_type = self.m_room_kwargs.trust_type or 0 --托管类型： 0 为不托管; 1 当局托管; 2 全局托管; 3 托管下局自动解散
    self.m_robot_second = self.m_room_kwargs.trust_time or 60 --托管时间设置
    self.m_ready_wait = self.m_room_kwargs.ready and ({0,30,60,120,180})[self.m_room_kwargs.ready+1] or 0 --首局未准备踢出选项(默认不开启)
    self.m_fandahua = self.m_room_kwargs.options == 1 --方块7可以反大花
    self.m_auto_ready = false --自动准备

    self.m_laird_uid = nil --第一次抢/叫主的uid
    self.m_teams = {{}, {}} -- { {seat, seat}, {seat, seat} } --队伍信息
    self.m_is_mingji = false --是否已明鸡
    self.m_flag_card = nil --用于找队友的牌
    self.m_round_point = 0 --当前回合已落地分数
    self.m_bookmaker_uid = nil --庄家
    self.m_round_discard = {} --这一圈玩家的出牌数据

    --打七
    self.m_bottom_card = {} --底牌
    self.m_bury_card = {} --埋底
    self.m_bury_uid = nil --当前埋底的玩家
    self.m_lord_color = nil  --叫主的花色
    self.m_rebel_color = nil --反主的花色
    self.m_rebel_total = 0 --反主次数
    self.m_curr_lord_seat = nil --当前叫主的座号
    self.m_curr_rebel_seat = nil --当前反主的座号
    self.m_round_base_card_type = nil --这一圈首出的牌型
    self.m_round_big_card_type = nil --这一圈玩家的出牌中最大的牌型
    self.m_round_big_card_seat = nil --这一圈玩家的出牌中最大的座号
    self.m_round_kill_card_seat = nil --这一圈玩家的杀牌的座号
    self.m_buckle_bottom = 0 -- 扣底分
    self.m_surrender_uid = nil --是否认输
    self.m_fandahua_flag = false --是否已经反过大花
    self.m_show_surrender = false --是否显示认输按钮
    self.m_prev_round_discard = {} --上一轮打出的牌
    self.m_all_score_cards = {{},{},{},{},{}} --每个玩家捡分的牌
    self.m_round_score_cards = {} --这一圈打出的分牌

    self:init()
    if _recovery_info then
        self:unserialize(_recovery_info)
    end
end

---@protected
function Room:init()
    self.m_fsm = statemachine.new()
    self.m_fsm:setupState({
        initial = "Init",
        events = {
            {name = "Ready", from = {"Init", "Settle"}, to = "Ready"},
            {name = "Deal", from = {"Ready", "Rob"}, to = "Deal"},
            {name = "Rob", from = {"Deal"}, to = "Rob"},
            {name = "Bury", from = {"Rob","Rebel"}, to = "Bury"}, --埋底
            {name = "Rebel", from = {"Bury"}, to = "Rebel"},
            {name = "Step", from = {"Rebel"}, to = "Step"},
            {name = "Settle", from = {"Step", "Rob"}, to = "Settle"},
            {name = "BigSettle", from = {"Settle", "Step"}, to = "BigSettle"}
        },
        callbacks = {
            onenterInit = function () self:fsm_on_init() end,
            onenterReady = function () self:fsm_on_ready() end,
            onenterDeal = function () self:fsm_on_deal() end,
            onenterRob = function () self:fsm_on_rob() end,
            onenterBury = function () self:fsm_on_bury() end,
            onenterRebel = function () self:fsm_on_rebel() end,
            onenterStep = function () self:fsm_on_step() end,
            onenterSettle = function () self:fsm_on_settle() end,
            onenterBigSettle = function () self:fsm_on_bigSettle() end,
        }
    })

    skynet.fork(function ()
        while true do
            skynet.sleep(100)
            self.m_timer = self.m_timer + 1
            if not self.m_is_start and self.m_timer >= const_game.ROOM_AUTO_DISMISS_TIME then
                local code = self:do_dismiss_room(const_code.DISMISS_ROOM_CODE.TIMEOUT)
                if code == const_code.SUCESS then
                    local resp = {}
                    resp.code = const_code.SUCESS
                    resp.flag = 0 --0 房主发起解散 1 投票发起解散 2 管理员强制解散
                    self:send_msg(const_cmd.DISMISS_ROOM, resp)

                    log.log("房间[%d][%d]秒未开始，自动解散成功！", self.m_room_id, self.m_timer)
                else
                    log.log("房间[%d][%d]秒未开始，自动解散失败！", self.m_room_id, self.m_timer)
                end
            elseif self.m_end_time == 0 and self.m_timer >= const_game.ROOM_START_AUTO_DISMISS_TIME then
                log.log("房间[%d][%d]秒未结束，自动结算并解散！", self.m_room_id, self.m_timer)
                self:big_settle(const_game.SETTLE_ROOM_STATUS.TimeOut) --需要大结算
                self:do_dismiss_room(const_code.DISMISS_ROOM_CODE.TIMEOUT)
            end

            if self.m_end_time == 0 and self.m_timer % const_game.SNAPSHOT_TIME == 0 then
                if self.m_snapshot_apply then
                    --log.log("room [%d] build snapshot", self.m_room_id)
                    self.m_snapshot_apply = false --清除快照申请标记
                    self:snapshot() --快照
                end
            end
        end
    end)
end

---@protected
function Room:fsm_on_init()
    --log.log("{Room:onInit}-------")
    self.m_room_status = const_game.ROOM_STATS.InitState

    --游戏未开局，未准备玩家?秒后强制踢出房间
    if self.m_ready_wait > 0 then
        if self.m_end_time == 0 and self.m_current_round == 1 and self.m_room_status == const_game.ROOM_STATS.InitState then
            skynet.fork(function()
                while self.m_room_status == const_game.ROOM_STATS.InitState do
                    skynet.sleep(100)
                    for uid, player in pairs(self.m_player_list) do
                        if player:get_status() == const_game.PLAYER_STATS.InitState and os.time() - player:get_join_time() >= self.m_ready_wait then
                            log.log("{room:fsm_on_init}room_id[%s], uid[%s], [%d]秒未准备, 被踢出房间.", self.m_room_id, uid, self.m_ready_wait)
                            self:exit_room(uid)
                        end
                    end
                end
            end)
        end
    end
end

---@protected
function Room:fsm_on_ready()
    --log.log("{Room:onReady}-------")
    self.m_room_status = const_game.ROOM_STATS.ReadyState
    self.m_fsm:doEvent("Deal")
end

---@protected
function Room:fsm_on_deal()
    --log.log("{Room:onDeal}-------")
    self.m_room_status = const_game.ROOM_STATS.DrawState
    self:deal()
    if not self.m_is_start then
        self.m_is_start = true --标记游戏已开局
        self:room_start()
    end
    self:round_update()
end

---@protected
function Room:fsm_on_rob()
    log.log("{Room:fsm_on_rob}-------")
    self.m_room_status = const_game.ROOM_STATS.LordState
    for _, playerObj in pairs(self.m_player_list) do
        playerObj:set_status(const_game.PLAYER_STATS.LordState) --设置玩家为抢地主/叫分状态
    end
    if self.m_lord_color then
        self.m_fsm:doEvent("Bury")
    else
        local next_uid = self.m_bookmaker_uid
        self.m_next_seat = self:get_seat_by_uid(next_uid) --轮到哪个座位操作
        local next_player = self:get_player(next_uid)
        --广播叫主通知
        local resp = {
            uid = tostring(next_uid),
            timer = self.m_robot_second,
            value = next_player:get_lord_color(),
        }
        self:send_msg(const_cmd.LORD_NOTICE, resp)
        --dump(resp, "叫主通知广播")
        self:start_robot_tick(next_uid) --启动托管定时器
    end
end

---@protected
function Room:fsm_on_bury()
    log.log("{Room:fsm_on_bury}-------")
    self.m_room_status = const_game.ROOM_STATS.BuryState

    ---@type Player
    local player
    local bottom_cards
    if self.m_rebel_color and self.m_curr_rebel_seat then --如果是反主
        player = self:get_player_by_seat(self.m_curr_rebel_seat)
        bottom_cards = self.m_bury_card
    else --抢/叫主底牌
        player = self:get_player_by_seat(self.m_curr_lord_seat)
        bottom_cards = self.m_bottom_card
    end
    --通知玩家拿底
    local resp = {
        uid = tostring(player:get_uid()),
        bottom_cards = {}
    }
    for u, p in pairs(self.m_player_list) do
        if u == player:get_uid() then
            for i, v in pairs(bottom_cards) do
                resp.bottom_cards[i] = {card=v}
                player:add_one_hand_card(v) --添加到玩家手牌
            end
            self:add_replay(const_cmd.CATCH_BOTTOM, resp, player:get_uid())
        end
        self:send_msg_by_agent(const_cmd.CATCH_BOTTOM, resp, p:get_agent())
    end
    --当前埋底的玩家
    self.m_next_seat = player:get_seat() --轮到哪个座位操作
    self:start_robot_tick(player:get_uid()) --启动托管定时器
end

---@protected
function Room:fsm_on_rebel()
    log.log("{Room:fsm_on_rebel}-------")
    self.m_room_status = const_game.ROOM_STATS.RebelState

    self.m_rob_list = {} --清理上轮反主记录
    local seat = self.m_curr_rebel_seat and self.m_curr_rebel_seat or self.m_curr_lord_seat
    local next_player = self:get_player_by_seat(self:get_next_seat(seat))
    self.m_next_seat = next_player:get_seat() --轮到哪个座位操作
    local resp = {
        color = self.m_fandahua_flag and 0 or next_player:get_rebel_color(self.m_rebel_color),
        uid = tostring(next_player:get_uid()),
        time = self.m_robot_second
    }
    self:send_msg(const_cmd.REBEL_NOTICE, resp)

    self:start_robot_tick(next_player:get_uid()) --启动托管定时器
end

---@protected
function Room:fsm_on_step()
    --log.log("{Room:onStep}-------")
    self.m_room_status = const_game.ROOM_STATS.StepState
    local hand_cards
    local no_flag_card
    for _, playerObj in pairs(self.m_player_list) do
        playerObj:set_status(const_game.PLAYER_STATS.StepState) --设置玩家为打牌状态
        --根据队友牌进行队伍分组
        no_flag_card = true
        hand_cards = playerObj:get_hand_cards()
        for _, v in pairs(hand_cards) do
            if v == self.m_flag_card then
                if not table.indexof(self.m_teams[1], playerObj:get_seat()) then
                    table.insert(self.m_teams[1], playerObj:get_seat())
                    no_flag_card = false
                    break
                end
            end
        end
        if no_flag_card then
            table.insert(self.m_teams[2], playerObj:get_seat())
        end
    end
    self:broadcast_show_card(nil, self.m_lord_color, self:get_lord_color()) --客户端显示朋友牌及主花色
    self:first_discard_notice()
end

---@protected
function Room:fsm_on_settle()
    --log.log("{Room:onSettle}-------")
    self.m_room_status = const_game.ROOM_STATS.SettleForRoundState
    for _, playerObj in pairs(self.m_player_list) do
        playerObj:set_status(const_game.PLAYER_STATS.SettleForRoundState) --设置玩家为结算状态
    end
    self:settle()
end

---@protected
function Room:fsm_on_bigSettle()
    --log.log("{Room:onBigSettle}-------")
    self.m_room_status = const_game.ROOM_STATS.SettleForRoomState
    self:big_settle(const_game.SETTLE_ROOM_STATUS.Normal)
    self:do_dismiss_room(const_code.DISMISS_ROOM_CODE.NORMAL) --正常解散房间
end


---@overload
function Room:ready(_uid, _data)
    local resp = {}

    if self.m_room_status ~= const_game.ROOM_STATS.InitState and self.m_room_status ~= const_game.ROOM_STATS.SettleForRoundState then
        --只有初始状态和重新开局状态才是有效的准备操作，防止客户端错误状态引响服务端
        self:reconnect(_uid)
        return
    end

    --如果当前为冻结状态，则强制重连（意图为让客户端等待大厅服返回玩家结算分数）
    if self.m_is_freeze then
        self:reconnect(_uid)
        return
    end
    ---@type Player
    local pobj = self:get_player(_uid)
    if pobj:get_status() ~= const_game.PLAYER_STATS.ReadyState then
        pobj:set_status(const_game.PLAYER_STATS.ReadyState) --设置玩家为准备状态
    end
    --广播准备状态
    resp = {player=tostring(_uid)}
    self:send_msg(const_cmd.READY, resp)

    self:snapshot_apply() --写快照申请

    --是否所有人都已准备
    local ready_num = 0
    for _, player in pairs(self.m_player_list) do
        if player:get_status() == const_game.PLAYER_STATS.ReadyState then
            ready_num = ready_num + 1
        end
    end
    if ready_num == self.m_max_player then
        self.m_fsm:doEvent("Ready")
    end
end

---@protected 新的一局开始，清理必要的上一局状态数据
function Room:next_round_init_data()
    self.m_rob_list = {}
    self.m_player_cards = {}
    self.m_bottom_card = {}
    self.m_last_discard = {}
    self.m_laird_uid = nil
    self.m_next_seat = -1
    for _, playerObj in pairs(self.m_player_list) do
        playerObj:next_round_init_data() --新的一局，清理玩家状态数据
        if self.m_robot_type == 1 then
            --如果为本局托管，则重置托管状态
            playerObj:set_is_robot(false)
        end
    end

    self.m_round_point = 0
    self.m_teams = {{}, {}}
    self.m_is_mingji = false
    self.m_flag_card = nil
    self.m_bookmaker_uid = nil
    self.m_round_discard = {}

    self.m_bottom_card = {} --底牌
    self.m_bury_card = {} --埋底
    self.m_bury_uid = nil --当前埋底的玩家
    self.m_lord_color = nil  --叫主颜色
    self.m_rebel_color = nil --反主
    self.m_rebel_total = 0 --反主次数
    self.m_curr_lord_seat = nil --当前叫主的座号
    self.m_curr_rebel_seat = nil --当前反主的座号
    self.m_round_base_card_type = nil
    self.m_round_big_card_type = nil
    self.m_round_big_card_seat = nil
    self.m_round_kill_card_seat = nil
    self.m_buckle_bottom = 0
    self.m_surrender_uid = nil --是否为认输
    self.m_fandahua_flag = false
    self.m_show_surrender = false --是否显示认输按钮
    self.m_prev_round_discard = {} --上一轮打出的牌
    self.m_all_score_cards = {{},{},{},{},{}} --每个玩家捡分的牌
    self.m_round_score_cards = {} --这一圈打出的分牌
end

--选出一个庄家uid
function Room:_make_bookmaker_uid()
    if self.m_last_shangyou then
        return self.m_last_shangyou
    else
        local uids = {}
        for uid, _ in pairs(self.m_player_list) do
            uids[#uids+1] = uid
        end
        return uids[utils.get_random(1, #uids)] --随机庄
        --return self:get_uid_by_seat(1) --房主当庄
    end
end

---@protected 发牌
function Room:deal()
    self:init_replay() --初始化回放数据

    self.m_bookmaker_uid = self:_make_bookmaker_uid() --庄家
    self.m_last_shangyou = nil

    local player_cards = {} --玩家起手牌
    for i = 1, self.m_max_player do
        player_cards[i] = {}
    end
    local all_cards
    if __RUNTIME == "DEV" then --开发环境，是否有配牌
        local customize_cards = utils.clone(sharetable.query("customize_cards"))
        --customize_cards = {}
        if customize_cards then
            log.log("-------------customize_card-------------\n %s", cjson.encode(customize_cards))
            all_cards = {
                0x17, 0x27, 0x37, 0x47,
                0x17, 0x27, 0x37, 0x47, 0x2, 0xf, 0xe, 0x1, 0x2, 0xf, 0xe, 0x1,
                0x1c, 0x13, 0x14, 0x15, 0x1c, 0x13, 0x18, 0x19, 0x1e, 0x1a, 0x1b, 0x12,
                0x1e, 0x1a, 0x24, 0x25, 0x1d, 0x26, 0x28, 0x29,

                --0x1d, 0x2a, 0x3e, 0x2b, 0x2c, 0x2d, 0x3e, 0x2e, 0x22, 0x16, 0x3d, 0x33, 0x34, 0x35, 0x3d,0x36,
                --0x38, 0x39, 0x3c, 0x3a, 0x3b, 0x3f, 0x3c, 0x43,
                --0x44, 0x45, 0x46, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x42,
                --0x14, 0x15, 0x16, 0x18, 0x19, 0x23, 0x1b, 0x12,
                --0x23, 0x24, 0x25, 0x26, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x22,
                --0x33, 0x34, 0x35, 0x36, 0x38, 0x39, 0x3a, 0x3b, 0x32,
                --0x43, 0x44, 0x45, 0x46, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x42,
            }
        end
    end

    --广播发牌通知
    local resp = {dealer_uuid=tostring(self.m_bookmaker_uid),current_round=self.m_current_round,cards_in_hand={}}
    for uid_, player in pairs(self.m_player_list) do
        self.m_player_cards[player:get_seat()] = {}
        player:set_status(const_game.PLAYER_STATS.DealState) --设置玩家为发牌状态
        self:send_msg(const_cmd.DEAL, resp, uid_)
        --self:add_replay(const_cmd.DEAL, resp, uid_)
    end

    if not all_cards then
        all_cards = utils.clone(card_type.shuffle(112)) --洗牌
    end
    local card_total = #all_cards
    self.m_bottom_card = {} --底牌
    local seq, seat = 0
    local card
    skynet.fork(function()
        while seq < card_total  do
            seq = seq + 1
            card = all_cards[seq]
            if seq <= card_total - 12 then
                seat = (seq - 1) % self.m_max_player + 1
                player_cards[seat][#player_cards[seat]+1] = card

                for uid_, player in pairs(self.m_player_list) do
                    if seat == player:get_seat() then
                        player:add_one_hand_card(card)
                        table.insert(self.m_player_cards[player:get_seat()], card)
                        self:send_msg(const_cmd.DRAW, {uid=tostring(uid_),card={card=card}}, uid_)
                        --self:add_replay(const_cmd.DRAW, {uid=tostring(uid_),card={card=card}}, uid_)
                    else
                        --self:send_msg(const_cmd.DRAW, {uid=tostring(uid_),card={card=0}}, uid_)
                    end
                end
                if seat % self.m_max_player == 0 then
                    skynet.sleep(40)
                end
            else
                self.m_bottom_card[#self.m_bottom_card+1] = card --底牌
            end
        end

        --写发牌战绩数据(战绩不单张发,一次写入)
        resp = {dealer_uuid=tostring(self.m_bookmaker_uid),current_round=self.m_current_round,cards_in_hand={}}
        for uid_, player in pairs(self.m_player_list) do
            resp.cards_in_hand = card_helper.reconv_cards(player:get_hand_cards())
            self:add_replay(const_cmd.DEAL, resp, uid_)
        end

        --发完牌后叫主状态
        skynet.timeout(50, function()
            self.m_fsm:doEvent("Rob")
        end)
    end)
end

---@public 叫主
function Room:rob(_uid, _data)
    --dump(_data, "rob".._uid)
    if self:get_fsm_state() ~= "Deal" and self:get_fsm_state() ~= "Rob" then
        log.log("{Room:rob} 房间[%d],局数[%d],uid[%d], 房间状态[%s]，非叫主状态.", self.m_room_id, self.m_current_round, _uid, self:get_fsm_state())
        self:reconnect(_uid)
        return
    end

    ---@type Player
    local player = self:get_player(_uid)
    local seat = player:get_seat()

    if _data.color > 0 and ((player:get_lord_color() & _data.color) == 0) then
        log.log("{Room:rob} 房间[%d],局数[%d],uid[%d],没有该花色[%d].", self.m_room_id, self.m_current_round, _uid, _data.color)
        self:reconnect(_uid)
        return
    end

    if self:get_fsm_state() == "Deal" then --发牌抢主
        if self.m_lord_color then
            log.log("{Room:rob} 房间[%d],局数[%d],uid[%d],已有人抢主.", self.m_room_id, self.m_current_round, _uid)
            self:reconnect(_uid)
            return
        else
            if _data.color > 0 then
                self.m_lord_color = _data.color
                self.m_curr_lord_seat = seat
                self.m_laird_uid = _uid
                self:set_flag_card(_data.color)
                --广播
                local resp = {code=const_code.SUCESS,uid=tostring(player:get_uid()),color=_data.color}
                self:send_msg(const_cmd.LORD, resp)
                self:add_replay(const_cmd.LORD, resp, _uid)
                player:do_action()
            end
        end
    elseif self:get_fsm_state() == "Rob" then --叫主
        if self.m_lord_color then
            log.log("{Room:rob} 房间[%d],局数[%d],uid[%d],已有人抢主.", self.m_room_id, self.m_current_round, _uid)
            self:reconnect(_uid)
            return
        end

        if not self.m_curr_lord_seat then
            if self.m_bookmaker_uid ~= self:get_uid_by_seat(seat) then
                log.log("{Room:rob} 房间[%d],局数[%d],uid[%d],没有轮到seat[%d]叫主.", self.m_room_id, self.m_current_round, _uid, seat)
                self:reconnect(_uid)
                return
            end
        elseif self:get_next_seat(self.m_curr_lord_seat) ~= seat then
            log.log("{Room:rob} 房间[%d],局数[%d],uid[%d],没有轮到seat[%d]叫主.", self.m_room_id, self.m_current_round, _uid, seat)
            self:reconnect(_uid)
            return
        end

        self.m_curr_lord_seat = seat
        self.m_rob_list[#self.m_rob_list+1] = {seat=seat,color=_data.color}
        --广播
        local resp = {code=const_code.SUCESS,uid=tostring(player:get_uid()),color=_data.color}
        self:send_msg(const_cmd.LORD, resp)
        self:add_replay(const_cmd.LORD, resp, _uid)
        player:do_action()

        if _data.color > 0 then
            self.m_lord_color = _data.color
            if not self.m_laird_uid then
                self.m_laird_uid = _uid
                self:set_flag_card(_data.color)
            end
            self.m_fsm:doEvent("Bury")
        elseif #self.m_rob_list < self.m_max_player then
            --如果放弃叫主,则下一个叫
            local next_player = self:get_player_by_seat(self:get_next_seat(seat))
            self.m_next_seat = self:get_seat_by_uid(next_player:get_uid()) --轮到哪个座位操作
            local resp = {
                uid = tostring(next_player:get_uid()),
                timer = self.m_robot_second,
                value = next_player:get_lord_color(),
            }
            --dump(resp, "下一个叫主")
            self:send_msg(const_cmd.LORD_NOTICE, resp)
            self:start_robot_tick(next_player:get_uid()) --启动托管定时器
        end
    end

    self:snapshot_apply() --写快照申请

    --如果在叫主阶段无人叫主，流局
    if not self.m_lord_color and #self.m_rob_list >= self.m_max_player then
        log.log("{Room:rob} 房间[%d],局数[%d],uid[%d],没人叫主流局.", self.m_room_id, self.m_current_round, _uid)
        self.m_fsm:doEvent("Settle")
    end
end

---@private 设置找朋友的牌
function Room:set_flag_card(_rob_clolor)
    --找朋友的牌
    if not self.m_flag_card then
        if _rob_clolor == 8 then
            self.m_flag_card = 0x17
        elseif _rob_clolor == 4 then
            self.m_flag_card = 0x27
        elseif _rob_clolor == 2 then
            self.m_flag_card = 0x37
        elseif _rob_clolor == 1 then
            self.m_flag_card = 0x47
        end
        self:broadcast_show_card(self.m_laird_uid, self.m_lord_color, self:get_lord_color())
    end
end

--向客户端发显示朋友牌，主花色广播
function Room:broadcast_show_card(_uid, _friend_color, _lord_color)
    local resp = {
        friend_card = _friend_color,
        lord_color = _lord_color
    }
    if not self.m_rebel_color then
        --只发给叫主玩家
        self:send_msg(const_cmd.SHOW_LORD_CARD, resp, _uid)
    else
        --反主广播所有人
        self:send_msg(const_cmd.SHOW_LORD_CARD, resp)
    end
    if not _uid then
        self:add_replay(const_cmd.SHOW_LORD_CARD, resp, 0)
    end
end

---@public 埋底
function Room:bury(_uid, _data)
    if self:get_fsm_state() ~= "Bury" then
        log.log("{Room:bury} 房间[%d],局数[%d],uid[%d], 房间状态[%s]，非埋底状态.", self.m_room_id, self.m_current_round, _uid, self:get_fsm_state())
        self:reconnect(_uid)
        return
    end

    local seat = self.m_curr_rebel_seat and self.m_curr_rebel_seat or self.m_curr_lord_seat
    if self:get_uid_by_seat(seat) ~= _uid then
        log.log("{Room:bury} 房间[%d],局数[%d],uid[%d],没有轮到该玩家埋底.", self.m_room_id, self.m_current_round, _uid)
        return self:reconnect(_uid)
    end
    if #_data.bottom_cards ~= 12 then
        log.log("{Room:bury} 房间[%d],局数[%d],uid[%d],埋底数据错误.", self.m_room_id, self.m_current_round, _uid)
        return self:reconnect(_uid)
    end

    ---@type Player
    local player = self:get_player(_uid)

    --手上的朋友牌不能全埋
    local hand_flag_num = 0 --手牌朋友牌张数
    local bury_flag_num = 0 --埋底朋友牌张数
    local hand_cards = player:get_hand_cards()
    for _, v in pairs(hand_cards) do
        if v == self.m_flag_card then
            hand_flag_num = hand_flag_num + 1
        end
    end
    for _, v in pairs(_data.bottom_cards) do
        if v.card == self.m_flag_card then
            bury_flag_num = bury_flag_num + 1
        end
    end
    if hand_flag_num > 0 and bury_flag_num == hand_flag_num then
        log.log("{Room:bury} 房间[%d],局数[%d],uid[%d],朋友牌[%d]手牌中共[%d]张不能全埋底.", self.m_room_id, self.m_current_round, _uid, self.m_flag_card, hand_flag_num)
        return self:reconnect(_uid)
    end

    --反主的牌不能埋底
    if self.m_rebel_color and self.m_rebel_color > 0 then
        local rob_card = self:get_rob_card_by_color(self.m_rebel_color)
        local rebel_num = 0 --底牌中含反的花色张数
        for _, v in pairs(_data.bottom_cards) do
            if v.card == rob_card then
                rebel_num = rebel_num + 1
            end
        end
        if rebel_num > 0 then
            log.log("{Room:bury} 房间[%d],局数[%d],uid[%d],反主的牌[%d]不能埋底.", self.m_room_id, self.m_current_round, _uid, rob_card)
            return self:reconnect(_uid)
        end
    end

    self.m_bury_uid = _uid
    self.m_bury_card = {}
    for i, v in pairs(_data.bottom_cards) do
        self.m_bury_card[i] = v.card
    end
    --移除埋底的手牌
    player:remove(self.m_bury_card)

    local resp = {code=const_code.SUCESS, bottom_cards=_data.bottom_cards, uid=tostring(_uid)}
    self:send_msg(const_cmd.CHANGE, resp)
    self:add_replay(const_cmd.CHANGE, resp, _uid)
    player:do_action()

    --进入反主状态
    self.m_fsm:doEvent("Rebel")
end

---@public 反主
function Room:rebel(_uid, _data)
    --dump(_data, "反主".._uid)
    if self:get_fsm_state() ~= "Rebel" then
        log.log("{Room:rob} 房间[%d],局数[%d],uid[%d], 房间状态[%s]，非反主状态.", self.m_room_id, self.m_current_round, _uid, self:get_fsm_state())
        self:reconnect(_uid)
        return
    end
    ---@type Player
    local player = self:get_player(_uid)
    local seat = player:get_seat()

    if self.m_next_seat ~= seat then
        log.log("{Room:rebel} 房间[%d],局数[%d],uid[%d],没有轮到seat[%d]操作.", self.m_room_id, self.m_current_round, _uid, seat)
        return self:reconnect(_uid)
    end

    if (not self.m_curr_rebel_seat and self.m_curr_lord_seat == seat) or self.m_curr_rebel_seat == seat then
        log.log("{Room:rebel} 房间[%d],局数[%d],uid[%d],不能反自己.", self.m_room_id, self.m_current_round, _uid)
        return self:reconnect(_uid)
    end

    if _data.color > 0 and (player:get_rebel_color() & _data.color == 0) then
        log.log("{Room:rebel} 房间[%d],局数[%d],uid[%d],没有该花色[%d].", self.m_room_id, self.m_current_round, _uid, _data.color)
        self:reconnect(_uid)
        return
    end
    if _data.color > 0 and self.m_rebel_color and self.m_rebel_color >= _data.color then
        if self.m_fandahua and self.m_rebel_color == 128 and _data.color == 1 then
            self.m_fandahua_flag = true
        else
            log.log("{Room:rebel} 房间[%d],局数[%d],uid[%d],[%d]不能反花色[%d].", self.m_room_id, self.m_current_round, _uid, self.m_rebel_color, _data.color)
            self:reconnect(_uid)
            return
        end
    end

    --保存本轮操作数据
    self.m_rob_list[#self.m_rob_list+1] = {seat=seat,color=_data.color}
    self.m_next_seat = self:get_next_seat(seat)

    local resp = {code=const_code.SUCESS, color=_data.color, uid=tostring(_uid)}
    self:send_msg(const_cmd.REBEL, resp)
    self:add_replay(const_cmd.REBEL, resp, _uid)
    player:do_action()
    self:snapshot_apply() --写快照申请

    if _data.color == 0 then
        if #self.m_rob_list == (self.m_max_player - 1) then
            --除了叫的玩家，其他人不反时进入出牌状态
            self.m_fsm:doEvent("Step")
        else
            --通知下一个玩家反主
            local next_player = self:get_player_by_seat(self.m_next_seat)
            self.m_next_seat = self:get_seat_by_uid(next_player:get_uid()) --轮到哪个座位操作
            local resp = {
                color = self.m_fandahua_flag and 0 or next_player:get_rebel_color(self.m_rebel_color, self.m_fandahua),
                uid = tostring(next_player:get_uid()),
                time = self.m_robot_second
            }
            self:send_msg(const_cmd.REBEL_NOTICE, resp)
            self:start_robot_tick(next_player:get_uid()) --启动托管定时器
        end
    else
        self.m_rebel_total = self.m_rebel_total + 1  --反主次数加1
        self.m_curr_rebel_seat = seat
        self.m_rebel_color = _data.color
        self.m_rob_list = {} --清空本轮操作
        self:broadcast_show_card(_uid, 0, self:get_lord_color()) --朋友花色传0是为了客户端此时不显示朋友牌
        --进入埋底状态
        self.m_fsm:doEvent("Bury")
    end
end

---@protected 第一个出牌者通知
function Room:first_discard_notice()
    ---@type Player
    local first_player = self:get_player_by_seat(self.m_curr_lord_seat)
    first_player:set_discard_status(0) --玩家出牌状态（用于重连）
    self.m_next_seat = first_player:get_seat() --轮到哪个座位操作

    local resp = {
        seat = first_player:get_seat(), --先出牌的座号
        timer = self.m_robot_second,
        new_round = true
    }
    if #self.m_teams[1] == 1 and self.m_teams[1][1] == first_player:get_seat() then
        self.m_show_surrender = true
        resp.show_surrender = true --客户端显示认输按钮
    end
    self:send_msg(const_cmd.STEP_START, {bury_seat=self:get_seat_by_uid(self.m_bury_uid)})--进入出牌状态广播,方便客户端清理叫主/反主特效
    self:add_replay(const_cmd.STEP_START, {}, 0)
    --dump(resp, "首出牌通知")
    self:send_msg_by_agent(const_cmd.DISCARD_TIPS, resp, first_player:get_agent())

    self:start_robot_tick(first_player:get_uid()) --启动托管定时器

    self:snapshot_apply() --写快照申请
end

---@public 认输
function Room:surrender(_uid, _data)
    if self:get_fsm_state() ~= "Step" then
        log.log("{Room:surrender} 房间[%d],局数[%d],uid[%d], 房间状态[%s]，非出牌状态.", self.m_room_id, self.m_current_round, _uid, self:get_fsm_state())
        self:reconnect(_uid)
        return
    end
    ---@type Player
    local player = self:get_player(_uid)
    local seat = player:get_seat()
    if #self.m_player_cards[seat] ~= #player:get_hand_cards() then
        log.log("{Room:surrender} 房间[%d],局数[%d],uid[%d], 房间状态[%s]，已出牌不能认输.", self.m_room_id, self.m_current_round, _uid, self:get_fsm_state())
        self:reconnect(_uid)
        return
    elseif self.m_teams[1] == 1 or self.m_teams[1][1] == self:get_seat_by_uid(_uid) then
        self.m_surrender_uid = _uid
        self:send_msg_by_agent(const_cmd.SURRENDER, {}, player:get_agent())
        self:add_replay(const_cmd.SURRENDER, {}, _uid)
        self.m_fsm:doEvent("Settle")
    else
        log.log("{Room:surrender} 房间[%d],局数[%d],uid[%d], 房间状态[%s]，不符合认输规则.", self.m_room_id, self.m_current_round, _uid, self:get_fsm_state())
        self:reconnect(_uid)
        return
    end
end

---@protected 明鸡和落地分数检测
function Room:_out_card_logic(_out_cards, _uid)
    ---@type Player
    local player = self:get_player(_uid)
    local point = self.m_round_point
    for _, card in pairs(_out_cards) do
        local point = card_type.get_card_index(card)
        if point == 5 or point == 10 then
            self.m_round_point = self.m_round_point + point
            table.insert(self.m_round_score_cards, card)
        elseif point == 13 then
            self.m_round_point = self.m_round_point + 10
            table.insert(self.m_round_score_cards, card)
        end
    end
    if self.m_round_point > point then
        log.log("{Room:_out_card_logic} 房间[%d], 局数[%d], 广播桌面分数变化:[%d]", self.m_room_id, self.m_current_round, self.m_round_point)
        self:send_msg(const_cmd.POINT_CHANGE, {point=self.m_round_point}) --桌面当前回合分数变化广播
        self:add_replay(const_cmd.POINT_CHANGE, {point=self.m_round_point}, 0)
    end
    --检测是否明鸡
    local out_ji = false
    for _, v in pairs(_out_cards) do
        if v == self.m_flag_card then
            out_ji = true
            break
        end
    end

    if out_ji then
        local is_mingji = false
        if #self.m_teams[1] == 1 then
            --1打3或1打4
            local hand_cards = player:get_hand_cards()
            is_mingji = true
            for _, v in pairs(hand_cards) do
                if v == self.m_flag_card then
                    is_mingji = false
                    break
                end
            end
        else
            if self.m_laird_uid ~= _uid then
                for _, v in pairs(_out_cards) do
                    if v == self.m_flag_card then
                        is_mingji = true
                        break
                    end
                end
            end
        end
        if is_mingji then
            log.log("{Room:_out_card_logic} 房间[%d], 局数[%d],明鸡<%s>", self.m_room_id, self.m_current_round, cjson.encode(self.m_teams))
            self.m_is_mingji = true
            local resp = {uid=tostring(_uid), teams=cjson.encode(self.m_teams)}
            self:send_msg(const_cmd.MINGJI, resp)
            self:add_replay(const_cmd.MINGJI, resp, _uid)
        end
    end
end

--玩家捡分
function Room:_pickup_point(_uid)
    if self.m_round_point > 0 then
        ---@type Player
        local player = self:get_player(_uid)
        player:add_pickup_point(self.m_round_point)
        --保存该玩家捡分的牌
        table.insertto(self.m_all_score_cards[player:get_seat()], self.m_round_score_cards)

        log.log("{Room:_pickup_point} 房间[%d], 局数[%d],广播玩家[%d]得分[%d]", self.m_room_id, self.m_current_round, _uid, self.m_round_point)
        local resp = {uid=tostring(_uid),point=player:get_pickup_point()}
        self:send_msg(const_cmd.PICKUP_POINT, resp) --广播玩家得分
        self:add_replay(const_cmd.PICKUP_POINT, resp, _uid)

        self.m_round_point = 0
        --self:send_msg(const_cmd.POINT_CHANGE, {point=0}) --桌面当前回合分数变化广播
    end
end

--牌局是否结束判定
function Room:_is_game_end()
    for _, p in pairs(self.m_player_list) do
        if #p:get_hand_cards() > 0 then
            return false
        end
    end
    return true
end

--队友模式，通过同组一个uid得到队友的uid
function Room:_get_teammate(_uid)
    if not self.m_laird_uid then
        for _, team in pairs(self.m_teams) do
            if table.indexof(team, _uid) then
                for _, uid in pairs(team) do
                    if uid ~= _uid then
                        return uid
                    end
                end
            end
        end
    end
end

--得到本局主花色
function Room:get_lord_color()
    local color
    if self.m_rebel_color then
        color = self.m_rebel_color
    else
        color = self.m_lord_color
    end
    return color
end

---@protected 根据叫/反主的花色得到叫/反主的牌值
function Room:get_rob_card_by_color(_color)
    if _color == 1 then
        return 0x47
    elseif _color == 2 then
        return 0x37
    elseif _color == 4 then
        return 0x27
    elseif _color == 8 then
        return 0x17
    elseif _color == 16 then
        return 0xe
    elseif _color == 32 then
        return 0xf
    elseif _color == 64 then
        return 0x1
    elseif _color == 128 then
        return 0x2
    end
end

---@public 玩家出牌操作
function Room:discard(_uid, _data)
    --dump(_data, "discard:".._uid, 10)
    local discard = _data.meld.cards

    if self:get_fsm_state() ~= "Step" then
        log.log("{Room:discard} 房间[%d], 局数[%d], uid[%d], 房间状态[%s]，非出牌状态.", self.m_room_id, self.m_current_round, _uid, self:get_fsm_state())
        self:reconnect(_uid)
        return
    end

    ---@type Player
    local player = self:get_player(_uid)
    local seat = player:get_seat()

    --如果不是轮到该玩家操作，则强制重连恢复客户端为正常状态
    if seat ~= self.m_next_seat then
        log.log("{Room:discard}没有轮到该玩家出牌. seat[%d], uid[%d]", seat, _uid)
        self:reconnect(_uid)
        return
    end

    local hand_cards = player:get_hand_cards()
    if not card_helper.have_card(discard, hand_cards) then
        self:reconnect(_uid)  -- 打出的牌型有误，重连
        log.log("房间号[%d],局数[%d],uid[%d],牌型有误,手牌没有此牌型! 打出[%s]，手牌[%s]",
                self.m_room_id, self.m_current_round, _uid,
                card_helper.cards_tostring(card_helper.conv_cards(discard)),
                card_helper.cards_tostring(hand_cards or {})
        )
        return
    end
    local cards = card_helper.conv_cards(discard)
    if #self.m_round_discard > 0 and #self.m_last_discard ~= #cards then
        self:reconnect(_uid)
        log.log("房间号[%d],局数[%d],uid[%d],打出牌张数有误! 打出[%s]，上家出牌[%s]",
                self.m_room_id, self.m_current_round, _uid,
                card_helper.cards_tostring(cards),
                card_helper.cards_tostring(self.m_last_discard or {})
        )
        return
    end

    local ctype = card_type.get_type(cards, self:get_lord_color())
    --dump(ctype, "牌型")
    --如果为首出，需要检测牌型
    if #self.m_round_discard == 0 then
        if not ctype then
            log.log("房间号[%d],局数[%d],uid[%d],首出[%s]非法牌型!",
                    self.m_room_id, self.m_current_round, _uid, card_helper.cards_tostring(cards))
            self:reconnect(_uid)
            return
        elseif ctype.l == 1 and (ctype.t == card_type.type.t_aak or ctype.t == card_type.type.t_aakn
                or ctype.t == card_type.type.t_akk or ctype.t == card_type.type.t_akkn) then
            log.log("房间号[%d],局数[%d],uid[%d],首出[%s],首出(多)边三轮只能为副牌!",
                    self.m_room_id, self.m_current_round, _uid, card_helper.cards_tostring(cards))
            self:reconnect(_uid)
            return
        else
            self.m_round_base_card_type = ctype
            self.m_round_big_card_type = ctype
            self.m_round_big_card_seat = seat
            self.m_round_kill_card_seat = nil
        end
    else
        if not card_helper.can_discard(hand_cards, discard, self.m_round_discard[1].cards, self.m_round_base_card_type, self:get_lord_color()) then
            log.log("房间号[%d],局数[%d],uid[%d],出牌[%s]不符合规则!",
                    self.m_room_id, self.m_current_round, _uid, card_helper.cards_tostring(cards))
            self:reconnect(_uid)
            return
        else
            --与首出牌型一致
            local kill_logic = function()
                if self.m_round_base_card_type.l == 0 and ctype.l == 1 then
                    if not self.m_round_kill_card_seat then
                        self.m_round_kill_card_seat = seat
                    else
                        self.m_round_kill_card_seat = 0
                    end
                end
            end
            if ctype and ctype.t == self.m_round_base_card_type.t then
                if ctype.l == 0 and self.m_round_big_card_type.l == ctype.l then
                    if card_type.get_card_color(self.m_round_discard[1].cards[1]) == card_type.get_card_color(cards[1]) then
                        if ctype.w > self.m_round_big_card_type.w then
                            self.m_round_big_card_type = ctype
                            self.m_round_big_card_seat = seat
                        end
                    end
                elseif ctype.l == 1 and self.m_round_big_card_type.l == ctype.l then --主-主
                    if ctype.w > self.m_round_big_card_type.w then
                        self.m_round_big_card_type = ctype
                        self.m_round_big_card_seat = seat
                        kill_logic()
                    end
                elseif self.m_round_big_card_type.l == 0 and ctype.l == 1 then --副-主
                    self.m_round_big_card_type = ctype
                    self.m_round_big_card_seat = seat
                    kill_logic()
                end
            end
        end
    end

    --出牌后,就不能显示认输按钮了
    self.m_show_surrender = false

    --删除玩家手牌
    player:discard(cards)
    player:do_action()
    --出牌分数及明鸡检测
    self:_out_card_logic(cards, _uid)

    self.m_last_discard = cards
    self.m_next_seat = self:get_next_seat(seat)

    local resp = {}
    resp.meld = _data.meld
    resp.meld.action = 0
    if self.m_round_kill_card_seat == seat then
        resp.meld.action = 2
    elseif self.m_round_big_card_seat == seat then
        resp.meld.action = 1
    end
    resp.uid = tostring(_uid)
    resp.first = #self.m_round_discard == 0 and true or false

    --出牌广播
    self:send_msg(const_cmd.DISCARD, resp)
    self:add_replay(const_cmd.DISCARD, resp, _uid)
    --dump(resp, "出牌广播")

    self.m_round_discard[#self.m_round_discard+1] = {uid=_uid, cards=card_helper.conv_cards(discard)}

    --下一个出牌玩家广播
    resp = {
        seat = self.m_next_seat,
        timer = self.m_robot_second,
        new_round = false
    }

    local is_settle = false
    --新一轮出牌判断
    if(#self.m_round_discard >= self.m_max_player) then
        self:_pickup_point(self:get_uid_by_seat(self.m_round_big_card_seat)) --最大牌的玩家捡分
        self.m_next_seat = self.m_round_big_card_seat

        if #player:get_hand_cards() == 0 then
            self:buckle_bottom(self.m_round_big_card_seat, self.m_round_big_card_type) --扣底
            is_settle = true --结算标志
        end

        resp.new_round = true
        resp.seat = self.m_round_big_card_seat
        self.m_prev_round_discard = utils.clone(self.m_round_discard) --保存上一轮的出牌
        self.m_round_discard = {}
        self.m_round_score_cards = {}
        self.m_round_base_card_type = nil
        self.m_round_big_card_type = nil
        self.m_round_big_card_seat = nil

    end
    if is_settle then
        self.m_fsm:doEvent("Settle")
    else
        --dump(resp, "出牌通知")
        self:send_msg(const_cmd.DISCARD_TIPS, resp)
        self:start_robot_tick(self:get_uid_by_seat(self.m_next_seat))
    end
end

---@protected 扣底
function Room:buckle_bottom(_seat, _card_type)
    --1打3，闲家输了不能算扣底分，只算抓分
    if #self.m_teams[1] == 1 then
        local idle_p = 0
        for _, player in pairs(self.m_player_list) do
            if table.indexof(self.m_teams[2], player:get_seat()) then
                idle_p = idle_p + player:get_pickup_point()
            end
        end
        if idle_p < 80 then
            log.log("{Room:buckle_bottom}房间号[%d],局数[%d],1打3或1打4，闲家得[%d]分，不扣底!", self.m_room_id, self.m_current_round, idle_p)
            return
        end
    end
    local multiple = 0
    if not table.indexof(self.m_teams[1], _seat) then -- 只有闲家大牌才触发扣底(?是否需要限制主才能扣底待确认)
        if _card_type.t == card_type.type.t_1 then
            multiple = 2
        elseif _card_type.t == card_type.type.t_2 then
            multiple = 4
        elseif _card_type.t == card_type.type.t_2n then
            multiple = 4 * _card_type.n
        elseif _card_type.t == card_type.type.t_akk or _card_type.t == card_type.type.t_aak then
            multiple = 6
        elseif _card_type.t == card_type.type.t_akkn or _card_type.t == card_type.type.t_aakn then
            multiple = 10
        end
    end
    if multiple > 0 then
        local point = 0
        local card
        for _, v in pairs(self.m_bury_card) do
            card = card_type.get_card_index(v)
            if card == 5 then
                point = point + 5
            elseif card == 10 or card == 13 then
                point = point + 10
            end
        end
        self.m_buckle_bottom = point * multiple
        log.log("{Room:buckle_bottom}房间号[%d],局数[%d],[%d]倍扣底[%d]分，共[%d]分!", self.m_room_id, self.m_current_round, multiple, point, self.m_buckle_bottom)
    end
end

---@protected 小结算
function Room:settle()
    self.m_room_status = const_game.ROOM_STATS.SettleForRoundState --标记房间为小结算状态

    local team_z, team_x = self.m_teams[1], self.m_teams[2] --庄家方,闲家方
    local point_z, point_x = 0, 0 --庄家方，闲家方得分

    local up_xian = 0 --闲家升多少级
    local multiple = 0 --庄家输赢倍数
    local score_x = 0 --每个闲家输赢分
    local score_x_sum = 0 --闲家输赢总分
    if self.m_surrender_uid then
        log.log("{Room:settle} 房间[%d],局数[%d],uid[%d], 房间状态[%s]，认输结算.", self.m_room_id, self.m_current_round, self.m_surrender_uid, self:get_fsm_state())
        --1打3/4认输
        for _, player in pairs(self.m_player_list) do
            up_xian = 1
            if table.indexof(team_x, player:get_seat()) then
                if up_xian > 0 then
                    score_x = (self.m_room_kwargs.base_score * 10 * up_xian) + (self.m_room_kwargs.base_score * 10 * self.m_rebel_total)
                    score_x_sum = score_x_sum + score_x
                else
                    score_x = -((self.m_room_kwargs.base_score * 10 * multiple) + (self.m_room_kwargs.base_score * 10 * self.m_rebel_total))
                    score_x_sum = score_x_sum + score_x
                end
            end
        end
    else
        for _, player in pairs(self.m_player_list) do
            if table.indexof(team_z, player:get_seat()) then
                point_z = point_z + player:get_pickup_point()
            else
                point_x = point_x + player:get_pickup_point()
            end
        end

        if (point_x + self.m_buckle_bottom) >= 200 then
            up_xian = 4
        elseif (point_x + self.m_buckle_bottom) >= 160 then
            up_xian = 3
        elseif (point_x + self.m_buckle_bottom) >= 120 then
            up_xian = 2
        elseif (point_x + self.m_buckle_bottom) >= 80 then
            up_xian = 1
        elseif (point_x + self.m_buckle_bottom) == 0 then
            multiple = 4
        elseif (point_x + self.m_buckle_bottom) < 40 then
            multiple = 2
        elseif (point_x + self.m_buckle_bottom) < 80 then --闲家抓80分以下(包括40分)不翻倍
            multiple = 1
        end

        --1打3或1打4，庄家获胜，倍数再翻一倍
        if #self.m_teams[1] == 1 then
            multiple = multiple * 2
        end

        for _, player in pairs(self.m_player_list) do
            if table.indexof(team_x, player:get_seat()) then
                if up_xian > 0 then
                    score_x = (self.m_room_kwargs.base_score * 10 * up_xian) + (self.m_room_kwargs.base_score * 10 * self.m_rebel_total)
                    score_x_sum = score_x_sum + score_x
                    player:set_top_level(up_xian)
                else
                    score_x = -((self.m_room_kwargs.base_score * 10 * multiple) + (self.m_room_kwargs.base_score * 10 * self.m_rebel_total))
                    score_x_sum = score_x_sum + score_x
                end
            end
        end
    end

    if #team_z == 2 and #team_z ~= #team_x then --2打3的情况
        for _, player in pairs(self.m_player_list) do
            if table.indexof(team_x, player:get_seat()) then
                player:set_round_score(score_x)
            else
                if player:get_uid() == self.m_laird_uid then --抢主的多输赢一份
                    player:set_round_score(-score_x*2)
                else
                    player:set_round_score(-score_x)
                end
            end
        end
    elseif #team_z == 2 and #team_z == #team_x then --2打2
        for _, player in pairs(self.m_player_list) do
            if table.indexof(team_x, player:get_seat()) then
                player:set_round_score(score_x)
            else
                player:set_round_score(-score_x)
            end
        end
    else --1打多
        for _, player in pairs(self.m_player_list) do
            if table.indexof(team_x, player:get_seat()) then
                player:set_round_score(score_x)
            else
                player:set_round_score(-score_x_sum)
            end
        end
    end

    self:save_round_record() --保存小局战绩详情

    --给客户端发小结算数据
    local resp = {}
    local player_data = {}
    for uid_, player_ in pairs(self.m_player_list) do
        player_:set_status(const_game.PLAYER_STATS.SettleForRoundState)
        player_data[#player_data+1] = {
            player = tostring(uid_),
            seat = player_:get_seat(),
            score = player_:get_round_score(),
            total = self:is_score_mode() and player_:get_total_score() or player_:get_table_score(),
            team = table.indexof(self.m_teams[1], player_:get_seat()) and 1 or 2,
            level = table.indexof(self.m_teams[2], player_:get_seat()) and up_xian or 0,
            rebel_total = table.indexof(self.m_teams[2], player_:get_seat()) and self.m_rebel_total or 0,
            buckle_points = table.indexof(self.m_teams[2], player_:get_seat()) and self.m_buckle_bottom or 0,
            pickup_points = player_:get_pickup_point(),
            team_points = table.indexof(self.m_teams[1], player_:get_seat()) and point_z or point_x + self.m_buckle_bottom,
        }
    end
    resp.player_data = player_data
    resp.round = self.m_current_round
    resp.is_surrender = self.m_surrender_uid and true or false --是否为认输
    resp.bury_bottom = card_helper.reconv_cards(#self.m_bury_card == 0 and self.m_bottom_card or self.m_bury_card)
    self:send_msg(const_cmd.SETTLE_FOR_ROUND, resp)

    --本局结束，初始化状态数据
    self:next_round_init_data()

    self:snapshot_apply() --写快照申请

    if self.m_current_round == self.m_max_rounds then
        self.m_fsm:doEvent("BigSettle") --正常大结算
    else
        self.m_current_round = self.m_current_round + 1 --局数加1
        --如果为全局托管，启动自动准备定时器
        if self.m_robot_type == 2 then
            for uid_, _ in pairs(self.m_player_list) do
                self:start_robot_tick(uid_) --启动托管定时器
            end
        elseif self.m_robot_type == 3 then --托管下局自动解散玩法
            self:robot_auto_dismiss()
        end
        --是否开启自动准备玩法
        if self.m_auto_ready then
            skynet.timeout(1500, function()
                for uid, player in pairs(self.m_player_list) do
                    if player:get_status() ~= const_game.PLAYER_STATS.ReadyState then
                        self:send_msg_by_agent(const_cmd.READY, self:ready(uid, {}), player:get_agent())
                    end
                end
            end)
        end
    end
end

---@protected @托管下局自动解散房间
function Room:robot_auto_dismiss()
    local robot_play = self:get_room_robot_play()
    if self.m_end_time == 0 and self.m_room_status == const_game.ROOM_STATS.SettleForRoundState and robot_play ~= nil then
        self.m_room_status = const_game.ROOM_STATS.CloseState --预解散状态
        --下发push信息
        local uinfo = robot_play:get_uinfo()
        self:send_msg(const_cmd.PUSH_MESSAGE,
                {type=1,text=string.format("[%s【%s】]处于托管状态，房间将于5秒后解散！", uinfo.name, uinfo.aid)})
        local delay = 5
        skynet.fork(function()
            --房间未解散 且 房间为重新开局状态 且 如果有人处理托管状态，则倒计时后解散房间，否则取消解散
            while self.m_end_time == 0 and self.m_room_status == const_game.ROOM_STATS.CloseState do
                if delay > 0 then
                    log.log("{Room:robot_auto_dismiss} room_id[%d], round[%d], uid[%d]处于托管状态,房间将于[%s]秒后解散", self.m_room_id, self.m_current_round, uinfo.aid, delay)
                    skynet.sleep(100)
                    delay = delay - 1
                else
                    log.log("{Room:robot_auto_dismiss} room_id[%d], round[%d], uid[%d]处于托管状态,房间解散", self.m_room_id, self.m_current_round, uinfo.aid)
                    self:big_settle(const_game.SETTLE_ROOM_STATUS.Robot) --需要大结算
                    self:do_dismiss_room(const_code.DISMISS_ROOM_CODE.ROBOT)
                    break
                end
            end
        end)
    end
end

---@overload 大结算
function Room:big_settle(_code)
    self.m_end_time = os.time()
    local resp = {}
    if self.m_current_round == self.m_max_rounds then
        resp.flag = 1 --正常解散
    else
        resp.flag = 0 --异常解散
    end
    local player_data = {}
    local player_item
    for uid_, playerObj in pairs(self.m_player_list) do
        player_item = {}
        player_item.player = tostring(uid_)
        player_item.seat = playerObj:get_seat()
        player_item.total_score = playerObj:get_table_score()
        player_item.is_owner = uid_ == self.m_room_owner and 1 or 0
        --player_item.top_score = playerObj:get_top_score()
        player_item.top_level = playerObj:get_top_level()
        player_item.win_cnt = playerObj:get_win_cnt()
        player_item.lose_cnt = playerObj:get_lost_cnt()

        if _code == const_game.SETTLE_ROOM_STATUS.Vote then
            --协议status: 0正常解散 1发起解散 2同意 3超时 4拒绝 5托管 6GM
            if self.m_voting == uid_ then
                player_item.status = 1
            elseif self.m_vote_list[uid_] == true then
                player_item.status = 2
            elseif self.m_vote_list[uid_] == false then
                player_item.status = 4
            else
                player_item.status = 3
            end
        elseif _code == const_game.SETTLE_ROOM_STATUS.Robot then
            if playerObj:get_is_robot() then --托管中的玩家
                player_item.status = 5
            else
                player_item.status = 0
            end
        elseif _code == const_game.SETTLE_ROOM_STATUS.TimeOut then
            player_item.status = 3
        elseif _code == const_game.SETTLE_ROOM_STATUS.GM then
            player_item.status = 6
        else
            player_item.status = 0
        end
        player_data[#player_data+1] = player_item
    end
    resp.player_data = player_data
    self:send_msg(const_cmd.SETTLE_FOR_ROOM, resp)
end

---@protected 将别人的手牌数据转换成可下发的格式(给客户端重连显示别人手牌张数)
function Room:conv_other_cards(_cards)
    local cards = {}
    for i, v in pairs(_cards) do
        cards[i] = {card=0}
    end
    return cards
end

---@private 根据座号得到该玩家叫/抢地主的操作信息
function Room:get_rob_info_by_seat(_seat)
    for _, v in pairs(self.m_rob_list) do
        if v.seat == _seat then
            return v.flag
        end
    end
end

---@overload 重连
function Room:reconnect(_uid)
    log.log("reconnect. room[%d],round[%d], uid[%d], room_status[%s]", self.m_room_id, self.m_current_round, _uid, self.m_room_status)
    ---@type Player
    local recon_player = self:get_player(_uid)
    local resp = {
        room_id = self.m_room_id,
        room_uuid = self.m_room_uuid,
        kwargs = cjson.encode(self.m_room_kwargs),
        owner_uuid = tostring(self.m_room_owner),
        room_status = self.m_room_status, --房间状态
        current_round = self.m_current_round,
        active_seat = self.m_next_seat, --当前出牌座位号
        discard_uuid = self.m_next_seat > 0 and tostring(self:get_uid_by_seat(self.m_next_seat)) or "",
        code = const_code.SUCESS,
        owner_info = self.m_room_kwargs.owner_info,
        round_discard_cards = {},
        player = {},

        table_point = self.m_round_point, --当前回合桌子上产生分数
        master_seat = self.m_curr_lord_seat, --叫主玩家座号
        rebel_seat = self.m_curr_rebel_seat, --反主的玩家座号
        change_seat = self.m_room_status == const_game.ROOM_STATS.BuryState and self.m_next_seat or 0,
        mingji = self.m_is_mingji,
        teams = self.m_is_mingji and cjson.encode(self.m_teams) or "",
        --max_seat = self.m_round_big_card_seat or 0, --最大牌座号
        table_score = self.m_round_point, --桌面分
        timer = self.m_next_seat > 0 and self.m_robot_second - self:get_player_by_seat(self.m_next_seat):get_robot_time() or 0, --当前操作倒计时
        show_surrender = self.m_show_surrender,
        master_color = self:get_lord_color() or 0, --主花色
        friend_color = self.m_lord_color or 0 --朋友牌花色
    }
    if self.m_room_status == const_game.ROOM_STATS.BuryState and self.m_next_seat == recon_player:get_seat() then
        --如果重连玩家正在埋底，则将底牌发下去，客户端需要显示底标标记
        resp.bottom_cards = card_helper.reconv_cards(self.m_bottom_card)
    end
    if self.m_room_status == const_game.ROOM_STATS.StepState and #self.m_round_discard > 0 then
        --如果为出牌状态,首出牌的玩家座号
        resp.first_seat = self:get_seat_by_uid(self.m_round_discard[1].uid)
    end
    if self.m_room_status >= const_game.ROOM_STATS.StepState then
        resp.bury_seat = self:get_seat_by_uid(self.m_bury_uid) --出牌状态下发埋底玩家的座号
    end


    local player_data
    local push_tb = {}
    for uid_, playerObj in pairs(self.m_player_list) do
        player_data = {
            seat = playerObj:get_seat(),
            player = tostring(uid_),
            info = cjson.encode(playerObj:get_uinfo()),
            status = playerObj:get_status(),
            is_online = (function()
                if playerObj:get_online() == 1 then
                    return 0 --在线
                else
                    return os.time() - playerObj:get_offline_time() --离线时长
                end
            end)(),
            round_score = self:is_score_mode() and playerObj:get_total_score() or playerObj:get_table_score(),
            cards_in_hand = _uid == uid_ and card_helper.reconv_cards(playerObj:get_hand_cards()) or self:conv_other_cards(playerObj:get_hand_cards()),
            discard = (function()
                local meld = {action=0}
                local seat
                for _, v in pairs(self.m_round_discard) do
                    if v.uid == uid_ then
                        seat = self:get_seat_by_uid(v.uid)
                        meld.cards = card_helper.reconv_cards(v.cards)
                        if self.m_round_kill_card_seat == seat then
                            meld.action = 2
                        elseif (self.m_round_kill_card_seat == 0 or not self.m_round_kill_card_seat) and self.m_round_big_card_seat == seat then
                            meld.action = 1
                        end
                        break
                    end
                end
                return meld
            end)(),
            total_score = self:is_score_mode() and playerObj:get_total_score() or playerObj:get_table_score(),
            robot = playerObj:get_is_robot(), --是否托管状态
            point = playerObj:get_pickup_point(), --玩家捡分
            rob_color = (function()
                local rs = -1
                if self.m_room_status == const_game.ROOM_STATS.LordState or self.m_room_status == const_game.ROOM_STATS.RebelState then
                    for _, v in pairs(self.m_rob_list) do
                        rs = -1
                        if v.seat == playerObj:get_seat() then
                            rs = v.color
                            break
                        end
                    end
                end
                return rs
            end)(),
        }
        resp.player[#resp.player+1] = player_data

        --投票状态处理
        if self.m_voting  then
            if _uid == uid_ then
                local vote_msg = {
                    room_id = self.m_room_id,
                    sponsor = tostring(self.m_voting),
                    expire_seconds = self.m_vote_timer
                }
                push_tb[#push_tb+1] = {cmd=const_cmd.SPONSOR_VOTE,data=vote_msg,addr=recon_player:get_agent()}
            end
        end
    end

    --dump(resp, "reconn-resp", 10)
    self:send_msg_by_agent(const_cmd.RECONNECT, resp, recon_player:get_agent())

    --将已经投过票的玩家广播给重连玩家
    if self.m_voting  then
        for uid_, _ in pairs(self.m_player_list) do
            if self.m_vote_list[uid_] then
                push_tb[#push_tb+1] = {cmd=const_cmd.PLAYER_VOTE,data={player=tostring(uid_),flag=self.m_vote_list[_uid] and false or true},addr=recon_player:get_agent()}
            end
        end
    end

    if self.m_room_status == const_game.ROOM_STATS.LordState then --叫主状态
        local player = self:get_player_by_seat(self.m_next_seat)
        resp = {
            uid = tostring(player:get_uid()),
            timer = self.m_robot_second,
            value = player:get_lord_color(),
        }
        push_tb[#push_tb+1] = {cmd=const_cmd.LORD_NOTICE,data=resp,addr=recon_player:get_agent()}
    elseif self.m_room_status == const_game.ROOM_STATS.RebelState then --反主状态
        local player = self:get_player_by_seat(self.m_next_seat)
        resp = {
            color = self.m_fandahua_flag and 0 or player:get_rebel_color(self.m_rebel_color, self.m_fandahua),
            uid = tostring(player:get_uid()),
            time = self.m_robot_second
        }
        push_tb[#push_tb+1] = {cmd=const_cmd.REBEL_NOTICE,data=resp,addr=recon_player:get_agent()}
    end

    --根据客户端需要，部分其他状态需要补发的广播
    if #push_tb > 0 then
        for _, push in pairs(push_tb) do
            --dump(cjson.encode(push), "补发广播")
            self:send_msg_by_agent(push.cmd, push.data, push.addr)
        end
    end
end

---@public 保存每局战绩详情
function Room:save_round_record()
    local score = {}
    for uid, playerObj in pairs(self.m_player_list) do
        score[tostring(uid)] = playerObj:get_round_score()
    end
    self:write_record_round(self.m_room_uuid, self.m_current_round, score)
end


---@protected 服务器主动同步手牌
function Room:sync_cards(_uid)
    ---@type Player
    local playerObj = self:get_player(_uid)
    self:send_msg(const_cmd.SYNCHRONISE_CARDS, card_helper.conv_cards(playerObj:get_hand_cards()), playerObj:get_agent())
end


---@protected 启动托管计时器
function Room:start_robot_tick(_uid)
    if self.m_robot_type > 0 then
        if not self:get_player(_uid):get_is_robot() then
            skynet.fork(function ()
                ---@type Player
                local playerObj = self:get_player(_uid)
                playerObj:set_robot_time(0)
                local flag = playerObj:get_action_seq()
                while playerObj:get_action_seq() == flag do
                    --log.log("room_status[%d], uid[%d], seq[%d], flag[%d]", self.m_room_status, _uid, playerObj:get_action_seq(), flag)
                    skynet.sleep(100)
                    if not self.m_voting then --投票阶段托管不计时
                        if playerObj:add_robot_time() >= self.m_robot_second then
                            self:robot(_uid, {status=true})  -- 玩家进入托管状态
                            self:do_robot(_uid)
                        end
                    end
                end
            end)
        else
            skynet.timeout(100, function ()
                if not self.m_voting then
                    self:do_robot(_uid)
                else
                    self:start_robot_tick(_uid)
                end
            end)
        end
    end
end

---@protected 托管逻辑执行
function Room:do_robot(_uid)
    log.log("{Room:do_robot}托管操作. room_status[%s], uid[%s]", self.m_room_status, _uid)
    if self.m_room_status == const_game.ROOM_STATS.SettleForRoundState then
        self:robot_ready(_uid)
    elseif self.m_room_status == const_game.ROOM_STATS.LordState then
        self:robot_rob(_uid)
    elseif self.m_room_status == const_game.ROOM_STATS.BuryState then
        self:robot_bury(_uid)
    elseif self.m_room_status == const_game.ROOM_STATS.RebelState then
        self:robot_rebel(_uid)
    elseif self.m_room_status == const_game.ROOM_STATS.StepState then
        self:robot_discard(_uid)
    end
end

---@protected 托管-准备
function Room:robot_ready(_uid)
    if self.m_robot_type == 2 then --只有全局托管才自动准备
        log.log("{room:robot_ready} 全局托管中，自动准备！")
        ---@type Player
        local playerObj = self:get_player(_uid)
        self:send_msg_by_agent(const_cmd.READY, self:ready(_uid, {}), playerObj:get_agent())
    end
end

---@protected 托管-抢/叫主
function Room:robot_rob(_uid)
    ---@type Player
    local playerObj = self:get_player(_uid)

    local resp = {color=0} --托管不叫主
    self:send_msg_by_agent(const_cmd.LORD, self:rob(_uid, resp), playerObj:get_agent())
    log.log("托管-抢/叫主[%d], data[%s]", _uid, cjson.encode(resp))
end

---@protected 托管-埋底
function Room:robot_bury(_uid)
    ---@type Player
    local playerObj = self:get_player(_uid)
    local hand_cards = playerObj:get_hand_cards()
    local bottom_cards = {}
    for _, v in pairs(hand_cards) do
        if self.m_flag_card ~= v then
            bottom_cards[#bottom_cards+1] = v
            if #bottom_cards == 12 then
                break
            end
        end
    end
    local resp = {bottom_cards=card_helper.reconv_cards(bottom_cards)}
    self:send_msg_by_agent(const_cmd.LORD, self:bury(_uid, resp), playerObj:get_agent())
    log.log("托管-埋底[%d], data[%s]", _uid, cjson.encode(resp))
end

---@protected 托管-反主
function Room:robot_rebel(_uid)
    ---@type Player
    local playerObj = self:get_player(_uid)

    local resp = {color=0} --托管不反主
    self:send_msg_by_agent(const_cmd.REBEL, self:rebel(_uid, resp), playerObj:get_agent())
    log.log("托管-反主[%d], data[%s]", _uid, cjson.encode(resp))
end

---@protected 托管-出牌
function Room:robot_discard(_uid)
    ---@type Player
    local playerObj = self:get_player(_uid)
    local resp = {meld={}}
    if #self.m_round_discard == 0 then
        --首出出单张
        local hand_cards = playerObj:get_hand_cards()
        local out = card_helper.get_one_card(hand_cards)
        for _, v in pairs(hand_cards) do
            if v == out then
                resp.meld.cards = {{card=v}}
                break
            end
        end
    else
        local rs = card_helper.get_robot_cards(self:get_lord_color(), playerObj:get_hand_cards(), self.m_round_base_card_type, self.m_round_discard[1].cards)
        resp.meld.cards = {}
        for _, v in pairs(rs) do
            table.insert(resp.meld.cards, {card=v})
        end
    end
    self:send_msg_by_agent(const_cmd.DISCARD, self:discard(_uid, resp), playerObj:get_agent())
end


---@protected 快照申请
function Room:snapshot_apply()
    self.m_snapshot_apply = true --该成员变量无需参与快照序列化/反序列化，所以没有在构造方法中定义
end

---@protected 快照
---@param _remove_uid number 如果需要移除的player的uid
function Room:snapshot(_remove_uid)
    --log.log("game snapshot. room_id: [%s]", self.m_room_id)
    if const_game.SNAPSHOT then
        if _remove_uid then
            room_model.del_player_key(self.m_room_id, _remove_uid)
        end
        room_model.room_to_redis(self.m_room_id, self:serialize())
        for i, v in pairs(self.m_player_list) do
            room_model.player_to_redis(self.m_room_id, i, v:serialize())
        end
    end
end

---@protected
function Room:serialize()
    local tb = {}
    local ignore = {"m_player_list", "m_snapshot_apply"}
    for k, v in pairs(self) do
        if string.sub(k,1, 2) == "m_" and not table.indexof(ignore, k) then
            if k == "m_fsm" then
                tb["m_fsm_state"] = self.m_fsm:getState()
            else
                tb[k] = v
            end
        end
    end
    return tb
end

---@protected
function Room:unserialize(_data)
    for k, v in pairs(_data) do
        if k == "m_fsm_state" then
            self.m_fsm:_setState_(_data.m_fsm_state)
        else
            self[k] = v
        end
    end

    --恢复Player对象
    local player_info
    for seat, uid in pairs(self.m_seat_list) do
        uid = tonumber(uid)
        player_info = room_model.player_from_redis(self.m_room_id, uid)
        local player = Player.new(uid, 0, seat, player_info.m_uinfo)
        self:add_player(uid, player)
        player:unserialize(player_info)
    end
end

---@public 查询桌子状态
function Room:table_status()
    local resp = {player={}}
    local player, uinfo
    for _, p in pairs(self.m_player_list) do
        uinfo = p:get_uinfo()
        player = {
            aid = p:get_uid(),
            nick = uinfo.name,
            icon = uinfo.iconUrl,
            score = p:get_table_score()
        }
        if p:get_online() == 1 then
            player.online = 0 --在线
        else
            player.online = os.time() - p:get_offline_time() --离线时长
        end
        resp.player[#resp.player+1] = player
    end
    resp.code = const_code.SUCESS
    resp.room_id = self.m_room_id
    resp.round = self.m_current_round
    return resp
end

--查看埋底
function Room:check_bury_card(_uid, _data)
    local resp = {code = const_code.SUCESS}
    if self.m_bury_uid == _uid then
        resp.bottom_cards = card_helper.reconv_cards(self.m_bury_card)
    end
    return resp
end

--查看捡分牌
function Room:check_score_card(_uid, _data)
    local resp = {code = const_code.SUCESS, check_cards = {}}
    local check_cards
    for _seat, _item in pairs(self.m_all_score_cards) do
        if _seat <= self.m_max_player then
            check_cards = {
                seat = _seat,
                uid = tostring(self:get_uid_by_seat(_seat)),
                card = card_helper.reconv_cards(_item)
            }
            table.insert(resp.check_cards, check_cards)
        end
    end
    return resp
end

--查看上一轮牌
function Room:check_prev_card(_uid, _data)
    local resp = {code = const_code.SUCESS, check_cards = {}}
    local check_cards
    for _, _item in pairs(self.m_prev_round_discard) do
        check_cards = {
            seat = self:get_seat_by_uid(_item.uid),
            uid = tostring(_item.uid),
            card = card_helper.reconv_cards(_item.cards)
        }
        table.insert(resp.check_cards, check_cards)
    end
    return resp
end

return Room